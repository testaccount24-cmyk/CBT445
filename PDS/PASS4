PAS4     TITLE 'PASS4 '
***********************************************************************
*                                                                     *
*  Called by PASS0.                                                   *
*                                                                     *
*  This makes two passes over the data, the 2nd and 4th. It is        *
*  called twice by PASS0, once before PASS3 is called and once after  *
*  PASS3 is called.                                                   *
*                                                                     *
* History:                                                            *
*   Fix bug printing the equate table at end of output.   CFK Apr 1999*
*   Handle weak external references (WXTRNs).             CFK May 1999*
*   Map ESD section list in ESD0.                         CFK Jan 2000*
*   Handle RSECTs.                                        CFK Jan 2000*
*   Generate AMODE and RMODE statements if needed.        CFK Jan 2000*
*   Map output line with OUTLINE macro.                   CFK Feb 2000*
*   Csect name is now set as the first address, so don't  CFK May 2000*
*   put it onto the output as a label.                                *
*   Generate trailing DS to make module its full length.  CFK Jly 2000*
*   Generate EQUates inline. This also allows for two     CFK Sep 2000*
*   labels at the same location.                                      *
*   Use equates for all registers                         CFK Oct 2000*
*   TXT pointers moved to ESD descriptor                  CFK May 2001*
*   Allow for csects with no TXT by pointing ROUT4 (@     CFK Jun 2001*
*   format routine) at EOF routine (CKEN)                             *
*   Put the address an EQUate points to into ADDR2        CFK Aug 2001*
*   Put comment on trailing DSes                          CFK Sep 2001*
*   Exit if no sections found                             CFK Oct 2001*
*   Support multiple csect object decks                   CFK Nov 2001*
*   1: Loop back if more csects to process                CFK Nov 2001*
*   2: Get csect name via CURRSECT                        CFK Dec 2001*
*   3: Don't put entry point on END card                  CFK Dec 2001*
*   Correctly print ENTRY statements                      CFK Dec 2002*
*   Don't zero NEXT to indicate EXTRNs printed            CFK Dec 2002*
*   Must process all csects in each pass                  CFK Jan 2003*
*   Generate COMmon area length correctly.                CFK May 2003*
*   Generate DXDs when needed.                            CFK May 2003*
*   Generate Dsect instead of DXD if PR aligned.          CFK Jun 2003*
*   Use standard linkage conventions.                     CFK Sep 2003*
*   Call format routines with standard linkage.           CFK Nov 2003*
*   Call PRINTP to print and punch records.               CFK Dec 2003*
*   Pass current section name to SAVA.                    CFK Dec 2003*
*   Pass ENTRYs in current section to SAVA.               CFK Dec 2003*
*   Reset label pointers in ART at start of each csect.   CFK Jan 2004*
*   Clear EXTRNs printed flag during exit.                CFK Jan 2004*
*                                                                     *
***********************************************************************
         ESDSDMAP                 entry in list of sections in ESD0
         ENTRYMAP                 ENTRY point descriptor      CFK*DEC01
         EXTRNMAP                 entry in list of EXTRNs in ESD2
         OUTLINE                  map output line             CFK*FEB00
PASS4    CSECT
         ENTER ,                  entry logic                 CFK*SEP03
         ENTRY ADA                next address, ref'ed by CONST
         EXTRN SPPR               csect
         EXTRN ASAVSECT           in SPPR csect               CFK*DEC03
         EXTRN PLCB               in SPPR csect
         EXTRN PRINTA             csect                       CFK*SEP03
         EXTRN FTXTA              csect                       CFK*SEP03
         EXTRN ART                csect
         EXTRN ARTCSECT           in ART csect                CFK*DEC03
         EXTRN NEL4               in ART csect                CFK*JAN04
         EXTRN CDN                csect
         EXTRN LCOM               in ESD5 csect
         EXTRN NPROG              in ESD0 csect               CFK*JAN00
         EXTRN CURRSECT           in ESD0, @ current section  CFK*JLY00
         EXTRN LCT                in PRINTA csect
         EXTRN ENDA               in TXT csect
         EXTRN USING              csect
         EXTRN PA                 in PASS1 csect
         EXTRN PAB                in PASS1 csect
         EXTRN NEXT               in ESD2 csect
         EXTRN NENT               in ESD1 csect
         EXTRN CONST              csect
         EXTRN SAVA               csect
         EXTRN SVK                in SAVA csect               CFK*DEC03
         EXTRN SAVASEC1           in ADDR csect               CFK*DEC03
         EXTRN BCV                csect
         EXTRN COTR               csect
         EXTRN SBCZ               in ARL csect
         EXTRN DECOMP             csect
         EXTRN ARL                csect
         ST    R15,PAR+20         put our base reg in parms to DECOMP
         L     R14,NPROGA         get @ NPROG in ESD0 csect   CFK*FEB03
         MVC   NUMSECT,0(R14)     get number of sections      CFK*FEB03
         L     R3,ACURRSEC        get @ current section ptr   CFK*FEB03
         LA    R14,4(R14)         get @ first section         CFK*FEB03
         ST    R14,0(R3)          set CURRSECT to @ first     CFK*FEB03
Z10A     DS    0H       loop back here if multiple csects     CFK*NOV01
         MVI   KEY4+3,X'00'       )       ind. not end of last card
         MVI   SIN,X'00'          ) clear work
         MVI   SKY,X'00'          )  areas
         MVI   LEN4+2,X'00'       )
         L     R3,COTR4           get @ COTR csect
         CLI   1(R3),C'D'         'D' in control card ?
         BNE   BCR                br if not
         MVI   PAS45,X'00'        else flag 2nd use of PASS4
BCR      BCR   0,0
         L     R3,=A(PA)          get @ PA in PASS1 csect     CFK*SEP03
         USING OUTLINE,R3         tell assembler              CFK*FEB00
         MVI   OUTLCC,C' '        clear
         MVC   OUTLCC+1(134),OUTLCC print area
         DROP  R3                 was OUTLINE                 CFK*FEB00
         L     R3,=A(PAB)         get @ PAB in PASS1 csect
         MVI   0(R3),C' '         clear
         MVC   1(134,R3),0(R3)     PAB
         L     R14,NPROGA         get @ NPROG in ESD0 csect   CFK*OCT01
         ICM   R14,B'1111',0(R14) get number of sections      CFK*OCT01
         BZ    Z99X               exit if no sections         CFK*OCT01
* put csect name into address table
         L     R9,ACURRSEC        get @ current section ptr   CFK*JAN03
         L     R9,0(R9)           get @ current ESD entry     CFK*JAN03
         USING ESDSDMAP,R9        tell assembler              CFK*JAN03
         MVC   SAVASECT,ESDNAME   pass csect name to SAVA     CFK*DEC03
         L     R1,=A(SAVASEC1)    get @ SAVA prm in ADDR      CFK*DEC03
         MVC   0(8,R1),ESDNAME    set to current csect name   CFK*DEC03
         L     R1,=A(ARTCSECT)    get @ current csect in ART  CFK*DEC03
         MVC   0(8,R1),ESDNAME    set to current csect name   CFK*DEC03
         L     R1,=A(ASAVSECT)    get @ current csect in SPPR CFK*DEC03
         MVC   0(8,R1),ESDNAME    set to current csect name   CFK*DEC03
         CLI   ESDNAME,C' '       private code ?              CFK*JAN03
         BE    PRIVCODE           if so don't call SAVA       CFK*JAN03
         MVI   SAVTYPE,X'61'      type=csect                  CFK*SEP03
         MVC   SAVADR,ESDADR3     csect address               CFK*SEP03
         MVC   SAVNAME,ESDNAME    pass csect name to SAVA     CFK*SEP03
         L     R15,ASAVC          get @ SAVA csect            CFK*SEP03
         LA    R1,SAVPARMS        get @ SAVA parms            CFK*SEP03
         BASR  R14,R15            call SAVA                   CFK*SEP03
PRIVCODE DS    0H                                             CFK*JAN03
         CLI   PAS45,X'FF'        SECOND USE OF PASS4 ?
         BE    Z20A               br. if not                  CFK*JAN04
* 4th pass only code
         L     R1,=A(NEL4)        get @ label pointers in ART CFK*JAN04
         MVC   0(8,R1),8(R1)      reset label pointers        CFK*JAN04
         MVC   ADA(4),ZZ4         reset ART output            CFK*JAN04
         MVI   ADALABEL,C' '      reset ART output            CFK*MAR04
         MVI   PAC,C' '           ) clear                     CFK*JAN04
         MVC   PAC+1(L'PAC-1),PAC )  output buffer            CFK*JAN04
         L     R2,=A(PA)          YES       get @ PA in PASS1 CFK*SEP03
         USING OUTLINE,R2         tell assembler              CFK*FEB00
         L     R4,ALCT4           START A      get @ LCT in PRINTA
         MVC   0(4,R4),FF94       NEW PAGE
         MVC   OUTINSTR(5),CSECT  PRINT CSECTS
         MVC   OUTLABEL,ESDNAME   copy csect name             CFK*JAN00
         TM    ESDINFO,ESDIRO     is this a RSECT ?           CFK*JAN00
         BZ    NOTRSECT           br. if not                  CFK*JAN00
         MVI   OUTINSTR,C'R'      else change CSECT to RSECT  CFK*JAN00
NOTRSECT DS    0H                                             CFK*JAN00
         L     R15,=V(PRINTP)     get @ PRINTP csect          CFK*DEC03
         LR    R1,R2              get @ print line            CFK*DEC03
         BASR  R14,R15            call PRINTP                 CFK*SEP03
* generate RMODE statement if necessary.                      CFK*JAN00
         TM    ESDINFO,ESDIRANY   is it RMODE ANY ?           CFK*JAN00
         BZ    NOTRMANY           branch if not               CFK*JAN00
         MVC   OUTINSTR(9),RMODEANY  copy c'RMODE ANY'        CFK*JAN00
         MVC   OUTLABEL,ESDNAME   copy csect name             CFK*JAN00
         L     R15,=V(PRINTP)     get @ PRINTP csect          CFK*DEC03
         LR    R1,R2              get @ print line            CFK*DEC03
         BASR  R14,R15            call PRINTP                 CFK*SEP03
NOTRMANY DS    0H                                             CFK*JAN00
* generate AMODE statement if necessary.                      CFK*JAN00
         TM    ESDINFO,ESDIA31    is it AMODE 31 or ANY ?     CFK*JAN00
         BNO   NOAMODE            branch if not               CFK*JAN00
         MVC   OUTINSTR(9),AMODEANY  copy c'AMODE ANY'        CFK*JAN00
         MVC   OUTLABEL,ESDNAME   copy csect name             CFK*JAN00
         TM    ESDINFO,ESDIAANY   is it AMODE ANY ?           CFK*JAN00
         BO    AMODEOK            branch if so                CFK*JAN00
         MVC   OUTOPER(3),=C'31 ' else make it AMODE 31       CFK*JAN00
AMODEOK  DS    0H                                             CFK*JAN00
         L     R15,=V(PRINTP)     get @ PRINTA csect          CFK*DEC03
         LR    R1,R2              get @ print line            CFK*DEC03
         BASR  R14,R15            call PRINTP                 CFK*SEP03
NOAMODE  DS    0H                                             CFK*JAN00
* print the ENTRY statements at the start of the listing
         L     R3,NENT4           get @ NENT in ESD1 csect
         LA    R4,4(R3)           get @ first entry           CFK*DEC02
         L     R3,0(R3)           get NENT, number of entries
         USING ENTRYMAP,R4        tell assembler              CFK*DEC01
         SR    R5,R5
         CR    R5,R3              any entries to print
         BE    NEN                br if not
ESDL1    CLC   ENTESDID,ESDID     is it for current csect ?   CFK*DEC01
         BNE   NXTENTRY           try next if not             CFK*DEC01
         MVC   OUTOPER(8),ENTNAME PRINT ENTRIES
         MVC   OUTINSTR,ENTRY     copy c'ENTRY'
         L     R15,=V(PRINTP)     get @ PRINTP csect          CFK*DEC03
         LR    R1,R2              get @ print line            CFK*DEC03
         BASR  R14,R15            call PRINTP                 CFK*SEP03
NXTENTRY DS    0H                                             CFK*DEC02
         LA    R4,ENTELEN(R4)     get @ next ENTRY slot       CFK*DEC02
         BCT   R3,ESDL1           br if more entries to print
         DROP  R4                 tell asm done with ENTRYMAP CFK*DEC01
NEN      DS    0H                                             CFK*DEC02
* print the EXTRN statements at the start of the listing if necessary
         CLI   EXTPRTD,X'FF'      EXTRNs printed ?            CFK*DEC02
         BE    NEXN               Yes, don't print again      CFK*DEC02
         MVI   EXTPRTD,X'FF'      No, flag not to print again CFK*DEC02
         L     R5,NEXT4           get @ NEXT in ESD2 csect    CFK*DEC01
         LA    R4,4(R5)           get @ 1st EXTRN             CFK*DEC01
         USING EXTRNMAP,R4        tell assembler
         L     R3,0(R5)           get NEXT, number of EXTRNS/WXTRNS  01
         LTR   R3,R3              any EXTRNS to print ?       CFK*DEC01
         BZ    NEXN               br if not
ESDL2    CLI   EXTTYPE,EXTTCM     Is it a Common area ?       CFK*MAY03
         BE    NEXB               br. if yes                  CFK*MAY03
         CLI   EXTTYPE,EXTTPR     is it a Pseudo Register ?   CFK*MAY03
         BE    NEXB               br. if yes                  CFK*MAY03
REX      MVC   OUTOPER(8),EXTNAME copy name referenced
         MVC   OUTINSTR,EXTRN     PRINT EXTRNS
         CLI   EXTTYPE,EXTTWX     weak external reference ?   CFK*MAY99
         BNE   NOTWEAK            branch if not               CFK*MAY99
         MVI   OUTINSTR,C'W'      else change EXTRN to WXTRN  CFK*MAY99
NOTWEAK  DS    0H                                             CFK*MAY99
         L     R15,=V(PRINTP)     get @ PRINTP csect          CFK*DEC03
         LR    R1,R2              get @ print area            CFK*DEC03
         BASR  R14,R15            call PRINTP                 CFK*SEP03
NEXB     LA    R4,EXTNEXT         get @ next EXTRN slot
         BCT   R3,ESDL2           br if more EXTRNs to print
         DROP  R4                 tell asm done with EXTRNMAP CFK*SEP02
         DROP  R2                 tell asm done with OUTLINE  CFK*FEB00
         B     NEXN               skip 2nd pass code          CFK*DEC03
* 2nd pass only code                                          CFK*DEC03
* put this csects entry points into the address table in SAVA CFK*DEC03
Z20A     DS    0H                                             CFK*DEC03
         L     R3,NENT4           get @ NENT in ESD1          CFK*DEC03
         LA    R4,4(R3)           else get @ 1st ENTRY's adr. CFK*DEC03
         USING ENTRYMAP,R4        tell assembler              CFK*DEC03
         ICM   R3,B'1111',0(R3)   get number of entries       CFK*DEC03
         BZ    NEXN               if no entries skip loop     CFK*JAN04
* start of loop to pass entry points to SAVA                  CFK*DEC03
Z20B     DS    0H                                             CFK*DEC03
         CLC   ENTESDID,ESDID     is it for current csect ?   CFK*DEC03
         BNE   Z20C               skip entry if not           CFK*DEC03
         MVC   SAVADR,ENTADR      pass ENTRY adr to SAVA      CFK*DEC03
         MVC   SAVNAME,ENTNAME    pass ENTRY name to SAVA     CFK*DEC03
         MVI   SAVTYPE,X'60'      ind. type of address        CFK*DEC03
         L     R15,ASAVC          get @ SAVA csect            CFK*DEC03
         LA    R1,SAVPARMS        get @ SAVA parms            CFK*DEC03
         BASR  R14,R15            call SAVA                   CFK*DEC03
Z20C     DS    0H                                             CFK*DEC03
         LA    R4,ENTELEN(R4)     get @ next ENTRY            CFK*DEC03
         BCT   R3,Z20B            br if more to process       CFK*DEC03
         DROP  R4                 done with ENTRYMAP          CFK*DEC03
* end of loop to pass entry points to SAVA                    CFK*DEC03
* 2nd and 4th pass code
NEXN     LA    R2,15              DROP USING TABLR
         SR    R3,R3              clear
         ST    R3,LNCT             line count
USLP     LA    R3,16(R3)
         STM   R2,R3,DRT          save work registers
         L     R15,US4            get @ USING csect           CFK*SEP03
         XC    USINGPRM,USINGPRM  clear USING parms           CFK*SEP03
         STC   R3,USINGPRM+2      tell using to drop this reg CFK*SEP03
         LA    R1,USINGPRM        get @ parms for USING       CFK*SEP03
         BASR  R14,R15            call USING                  CFK*SEP03
*  USING parms are:
*    +0  hex flag, 00 - drop, 01 or 02 - insert, 03 - retrieve
*    +2  1 byte address part of instruction (register)
*    +3  1 byte address part of instruction
*    +4  3 byte current loc (?) - if insert
*    +7  1 byte instruction format from AXN table
         LM    R2,R3,DRT          reload work registers
         BCT   R2,USLP            br if more registers to drop
         MVC   PLC(4),ZZ4         ) zero
         MVC   FORHF(4),ZZ4       )  all
         MVC   FFC(4),ZZ4         )   these
         MVC   ACT(4),ZZ4         )    fields
         MVI   COBRG+3,X'30'
         MVC   FFAD(4),ZZ4        ) zero some
         MVC   COBF(4),ZZ4        )  more fields
         MVC   XSX(4),NXSX        copy f'60'
         MVC   USINGPRM+4(3),ZZ4  ) zero USING parms          CFK*SEP03
         MVI   FFC,X'FF'
         L     R9,ACURRSEC        get @ current section ptr.  CFK*MAY01
         L     R9,0(R9)           get @ current section desc. CFK*MAY01
         USING ESDSDMAP,R9        tell asembler               CFK*MAY01
         L     R3,ESDCBUF         get @ TXT header            CFK*MAY01
         MVC   USINGPRM+4(3),0(R3)  copy 1st TXT adr to USING parms P03
         L     R3,AENDA           get @ ENDA in TXT csect
         L     R4,COTR4           get @ COTR csect
         CLI   7(R4),C'A'         'A' in control card ?
         BNE   NAS                br. if not
         MVI   FFC+1,X'FF'
         CLI   0(R3),C' '         end address blank ?
         BE    PFT                br if yes
         MVI   USINGPRM,X'01'     else flag insert call       CFK*SEP03
         MVC   USINGPRM+4(3),0(R3)  copy to USING parms       CFK*SEP03
         B     PFT
NAS      CLC   0(3,R3),ZZ4        end address zero ? (but why check ?)
         CLC   0(3,R3),FT08       end address x'000008' ?
         BE    TFTR               br. if yes
         CLI   0(R3),C' '         end address blank ?
         BE    TFTR               br. if yes
         MVC   FFAD+1(3),0(R3)    copy end address
         L     R3,ESDTBUF         get @ TXT                   CFK*MAY01
         CLI   0(R3),X'90'        input starts with STM ?
         BE    NFT                br. if yes
         CLI   0(R3),X'05'        input starts with BALR ?
         BE    NFT                br. if yes
         MVI   PLC+1,X'FF'
         MVI   KEY4+3,X'02'
         CLC   16(2,R3),FEH       = x'9847' (LM 4,7, ...) ?
         BE    TFTR               br. if equal
         CLI   0(R3),X'47'        input starts with BC ?
         BE    LFTXTB             br. if yes
         MVI   COBF,X'01'         else set flag
         B     LFTXTB
TFTR     L     R3,ESDTBUF         get @ TXT                   CFK*MAY01
         MVI   USINGPRM+6,X'08'   ) update USING              CFK*SEP03
         MVC   B15(4),ZZ4         )  parms
         CLC   8(4,R3),FFBR       = STM  14,12,12(13) ?
         BE    PFT                br if so
         LA    R3,4(R3)           get @ next instr.
         DROP  R9                 was ESDSDMAP                CFK*MAY01
         L     R9,XSX             )
         LA    R9,8(R9)           ) bump up XSX
         ST    R9,XSX             )
         MVI   USINGPRM+6,X'00'   update USING parms          CFK*SEP03
         CLC   8(4,R3),FFBR       = STM  14,12,12(13) ?
         BE    PFT                br if so
NFT      MVI   FFC+1,X'FF'
         MVI   USINGPRM,X'01'     flag insert call to USING   CFK*SEP03
         MVI   FORHF,X'FF'
         B     LFTXTB
PFT      MVI   USINGPRM+7,X'01'   tell USING to insert this reg K*SEP03
         MVI   USINGPRM+2,X'F0'   set reg to insert to 15     CFK*SEP03
         ST    R3,BRT             save @ next instruction
         BAL   R9,USST            Call USST to generate USING card
         L     R15,US4            get @ USING csect           CFK*SEP03
         LA    R1,USINGPRM        get @ parms                 CFK*SEP03
         BASR  R14,R15            call USING                  CFK*SEP03
*  USING parms are:
*    +0  hex flag, 00 - drop, 01 or 02 - insert, 03 - retrieve
*    +2  1 byte address part of instruction
*    +3  1 byte address part of instruction
*    +4  3 byte current loc (?) - if insert
*    +7  1 byte instruction format from AXN table
         L     R3,BRT             reload @ next instruction
         CLI   FFC+1,X'FF'
         BE    LFTXTB
         MVI   FFC,X'00'
         MVI   FORHF,X'FF'
         MVI   PLC+1,X'FF'        YES
         CLI   16(R3),X'58'
         BNE   NLS7
         MVC   FFAD+2(2),18(R3)   FIRST EXEC ADDRESS
         NI    FFAD+2,X'0F'
         L     R5,B15
         A     R5,FFAD
         LA    R3,4(R3)
         S     R5,XSX
         SRL   R5,2
         ST    R5,B15
         LTR   R5,R5
         BC    12,NLS7
         B     NLS8
NLS7     MVC   B15(4),ZZ4         set B15 to zero
NLS8     MVC   FFAD+2(2),18(R3)
         NI    FFAD+2,X'0F'
         MVI   KEY4+3,X'02'       SET CONSTANT MODE
         MVC   COBRG+3(1),18(R3)
         NI    COBRG+3,X'F0'
         MVC   COBA(4),ZZ4
         L     R5,ALCOM4          get @ LCOM in ESD5 csect
         L     R5,0(R5)           get common length
         LA    R5,4095(R5)
         SR    R4,R4              clear high reg. of pair
         D     R4,F100            divide by 4096
         L     R6,B15
         SR    R6,R5              subtract number of common pages
         ST    R6,B15
         LA    R5,3(R5)
         SLL   R5,4               multiply by 4
         ST    R5,COBR
* start of a loop
LNNP     L     R5,COBR
         LA    R5,16(R5)
         ST    R5,COBR
         STC   R5,USINGPRM+2        put reg. no. into USING prms *SEP03
         CLC   COBR+3(1),COBRG+3
         BNE   OREG
         L     R7,B15
         C     R7,ZZ4
         BNH   OREG
         M     R6,F100           mul by 4096
         ST    R7,COBA
OREG     MVC   USINGPRM+4(3),COBA+1 set current adr passed to USING P03
         L     R4,COBA
         A     R4,F100           add 4096
         ST    R4,COBA
         BAL   R9,USST           call USST to generate USING card
         B     LUS4              and br. round subroutine
* subroutine to generate USING card
USST     ST    R9,AFTA           save return address
         XC    REGT(3),REGT      clear BCV parms
         MVC   REGT+3(1),USINGPRM+2 pass register no. to BCV  CFK*SEP03
         MVC   SAVADR,USINGPRM+4    pass adr. to SAVA csect   CFK*SEP03
         MVI   SAVTYPE,X'60'     ind. type of address
         MVC   SAVNAME,SPACES    clear label                  CFK*APR00
         L     R15,ASAVC         get @ SAVA csect             CFK*SEP03
         LA    R1,SAVPARMS       get @ parms                  CFK*SEP03
         BASR  R14,R15           call SAVA                    CFK*SEP03
         L     R14,BCV4          get @ BCV csect
         ST    R13,REGT+4        put R13 where BCV expects it CFK*SEP03
         CNOP  2,4
         BALR  R14,R14           call BCV
REGT     DC    F'0'
         DC    F'0'              R13 (re)loaded from here
         L     R4,=A(PA)         get @ PA in PASS1 csect      CFK*SEP03
         USING OUTLINE,R4        tell assembler               CFK*FEB00
         MVC   OUTOPER(8),SAVOUTLB copy name of this address  CFK*APR00
         MVC   OUTINSTR(6),USI4  copy c'USING '
         LA    R5,7              max label length - min label length
         LA    R3,OUTOPER+7      get @ end of label
CEC      CLI   0(R3),C' '        space ?
         BNE   INSC              no, found end of label
         BCTR  R3,0              else take 1 off ptr
         BCT   R5,CEC            and loop if more to check
INSC     MVI   1(R3),C','        put , after label
         MVC   2(2,R3),REGT      copy register number
         CLI   PAS45,X'FF'       2nd use of PASS4 ?
         BE    NPCB              br. if not
* 4th pass only code
         L     R15,=V(PRINTP)    get @ PRINTP csect           CFK*DEC03
         LR    R1,R4             get @ print area             CFK*DEC03
         BASR  R14,R15           call PRINTP                  CFK*SEP03
* 2nd and 4th pass code
NPCB     L     R9,AFTA           reload return address
         BR    R9                and return
         DROP  R4                tell asm done with OUTLINE   CFK*FEB00
* end of USST subroutine
LUS4     L     R15,US4           get @ USING csect            CFK*SEP03
         MVI   USINGPRM,X'01'    ind. insert call             CFK*SEP03
         MVI   USINGPRM+7,X'01'                               CFK*SEP03
         LA    R1,USINGPRM       get @ parms for USING        CFK*SEP03
         BASR  R14,R15           call USING                   CFK*SEP03
*  USING parms are:
*    +0  hex flag, 00 - drop, 01 or 02 - insert, 03 - retrieve
*    +2  1 byte address part of instruction
*    +3  1 byte address part of instruction
*    +4  3 byte current loc (?) - if insert
*    +7  1 byte instruction format from AXN table
         CLC   COBR+3(1),COBRG+3
         BL    LNNP               loop back
* end of first big loop
         L     R4,COBA
         S     R4,F100            subtract 4096
         A     R4,FFAD
         ST    R4,FFAD
LFTXTB   L     R14,APLCB          get @ PLCB in SPPR csect
         MVC   4(36,R14),PLC      copy our PLC into SPPRs PLC
* start of main loop
LFTXT4   L     R15,AFTXTA         FETCH TEXT, get @ FTXTA     CFK*SEP03
         CLI   SKY,X'01'          end of TXT ?
         BE    CKEN               br. if yes
         MVC   SKY(1),KEY4+3      copy eof flag
         CLI   LEN4+2,X'FF'
         LA    R1,FTXTAPRM        get @ FTXTA parms           CFK*OCT03
         BNE   BALRF
         MVI   KEY4+3,X'02'
BALRF    BASR  R14,R15            call FTXTA                  CFK*SEP03
         CLI   KEY4+3,X'01'       end of last card ?
         BNE   NSKY               br. if not
         MVI   SKY,X'01'          else flag end of TXT
NSKY     MVC   KEY4+3(1),SKY
         BAL   R9,AFT             call AFT subroutine
         B     CKK2               branch round subroutine
***********************************************************************
* Subroutine to put the address on the output if necessary            *
*                                                                     *
* Uses R3, R4, R5, R9, R14 + regs used by PRINT (R12), ART (R3 and R4)*
*                                                                     *
***********************************************************************
AFT      ST    R9,AFTA            save return address
         CLI   PAS45,X'FF'        SECOND USE OF PASS4
         BE    CKK                return if not
* 4th pass only code
         LA    R9,PAC             get @ output buffer         CFK*SEP00
         USING OUTLINE,R9         tell assembler              CFK*SEP00
         CLC   ADA(4),ZZ4         is ADA zero ?
         BE    FXN                br. if so (ART not called yet)
CFF      CLI   ADA,X'FF'          any known addresses left ?
         BE    CKK                go to return if not
         CLI   ADA,X'61'          is it a CSECT ?             CFK*MAY00
         BE    FXN                br. if so (already printed) CFK*MAY00
         CLC   LOC3,ADAADR        current adr. = this adr. ?  CFK*MAY00
         BE    XNA                yes - go print it
         BL    CKK                we're not there yet, return to caller
* put ADDR2 onto output                                       CFK*AUG01
         UNPK  OUTADDR2(7),ADAADR(4)   unpack address         CFK*AUG01
         TR    OUTADDR2,=C'0123456789ABCDEF'-240  make chars  CFK*AUG01
         MVI   OUTADDR2+6,C' '    clear gash byte             CFK*AUG01
* put -n onto output                                          CFK*SEP00
         XR    R3,R3              clear reg                   CFK*SEP00
         ICM   R3,B'0111',LOC3    get current address         CFK*SEP00
         XR    R5,R5              clear reg                   CFK*SEP00
         ICM   R5,B'0111',ADAADR  get labels address          CFK*SEP00
         SR    R3,R5              calc difference             CFK*SEP00
         CVD   R3,DWC             make length PD              CFK*SEP00
         MVC   OUTOPER+1(9),=X'604020202020202120' - and EDit mask EP00
         LA    R1,OUTOPER+9       point at last byte          CFK*SEP00
         EDMK  OUTOPER+2(8),DWC+4 make decimal                CFK*SEP00
         MVC   OUTOPER+2(8),0(R1) move down length            CFK*SEP00
* put address onto output                                     CFK*SEP00
XNA      DS    0H                                             CFK*SEP00
         MVC   OUTLABEL,ADALABEL  else copy label             CFK*SEP00
* get next address                                            CFK*SEP00
FXN      L     R15,BART           FETCH NEXT ADDRESSP         CFK*SEP03
         MVC   ADB+1(3),ADAADR    copy current address        CFK*SEP00
         MVC   ADBC(4),ADA        copy current address        CFK*SEP00
         LA    R1,ARTPARMS        get @ parms                 CFK*SEP03
         BASR  R14,R15            call ART csect              CFK*SEP03
* print EQUate if necessary                                   CFK*SEP00
         CLI   OUTOPER+1,C'-'     -n on card ?                CFK*SEP00
         BE    DOPRINT            yes, print it               CFK*SEP00
* current address must equal last address                     CFK*SEP00
         CLC   LOC3,ADAADR        current adr. = next adr. ?  CFK*SEP00
         BL    RETLABEL           we're not there yet, return to caller
DOPRINT  DS    0H                                             CFK*SEP00
         CLI   OUTLABEL,C' '      label on card ?             CFK*SEP00
         BE    CFF                no, skip it (must be CSECT) CFK*SEP00
         MVC   OUTINSTR(3),EQU    put EQU on card             CFK*SEP00
         MVI   OUTOPER,C'*'       put * on card               CFK*SEP00
         L     R15,=V(PRINTP)     get @ PRINTP csect          CFK*DEC03
         LR    R1,R9              get @ print line            CFK*DEC03
         BASR  R14,R15            call PRINTP                 CFK*SEP03
         MVI   PAC,C' '           ) clear                     CFK*SEP00
         MVC   PAC+1(L'PAC-1),PAC )  output buffer            CFK*SEP00
         B     CFF                loop back to process next address
RETLABEL DS    0H                                             CFK*SEP00
         L     R9,=A(PA)          get @ PA in PASS1 csect     CFK*SEP03
         MVC   OUTLABEL,PAC+OUTLABEL-OUTLINE  copy label      CFK*SEP00
         DROP  R9                 tell asm done with OUTLINE  CFK*SEP00
* 2nd and 4th pass code
CKK      L     R9,AFTA            reload return address
         BR    R9                 and return
* end of AFT subroutine
CKK2     B     LFTXT5
* end of input TXT reached
CKEN     XC    PAR(16),PAR        clear DECOMP parms
         MVC   PAR+16(4),ONE      copy f'1'
         BAS   R14,BDCM           call DECOMP (does nothing)  CFK*SEP03
         XC    PAR+16(4),PAR+16   clear DECOMP parms
         L     R14,ACURRSEC       get @ section desc table    CFK*JAN03
         L     R6,0(R14)          get @ entry (& keep adr)    CFK*FEB03
         LA    R3,ESDENTLN(R6)    get @ next section          CFK*FEB03
         ST    R3,0(R14)          save @ next entry           CFK*JAN03
         L     R3,NUMSECT         get number of sections      CFK*FEB03
         BCTR  R3,0               subtract one section done   CFK*JAN03
         ST    R3,NUMSECT         store it back               CFK*FEB03
         LTR   R3,R3              more to process ?           CFK*JAN03
         BNZ   Z10A               back to start if so         CFK*JAN03
         L     R3,=A(PA)          get @ PA in PASS1 csect     CFK*SEP03
         USING OUTLINE,R3         tell assembler              CFK*JLY00
         MVI   2(R3),C' '         ) clear
         MVC   3(97,R3),2(R3)     )  print area
         CLI   PAS45,X'FF'        SECOND USE OF PASS4 ?
         BE    EPS2               br. if not
* 4th pass only code
* add trailing DS if necessary
*        L     R6,ACURRSEC        get @ current section ptr.  CFK*JLY00
*        L     R6,0(R6)           get @ current section desc. CFK*JLY00
         USING ESDSDMAP,R6        tell assembler              CFK*JLY00
         L     R5,ESDLEN          get section length          CFK*DEC01
         XR    R2,R2              clear register              CFK*JLY00
         ICM   R2,B'0111',LOC3    get current address         CFK*JLY00
         AH    R2,LEN2            add last instr. length      CFK*JLY00
         A     R5,ESDADR          add csect start adr.        CFK*FEB04
         SR    R5,R2              subtract current address    CFK*JLY00
         BZ    NOTRLDS            if zero done                CFK*JLY00
         BP    ADDDS              if +ve add DS to make up    CFK*SEP00
* text extends past the section length in ESD !               CFK*SEP00
         MVC   MSG1I1,ESDNAME     add section name to message CFK*FEB04
         CVD   R5,DWC             make length PD              CFK*FEB04
         MVC   MSG1I2,=X'402020206B2020206B202120'  add mask  CFK*FEB04
         LA    R1,MSG1I2+11       point at last byte          CFK*FEB04
         EDMK  MSG1I2,DWC+3       make decimal                CFK*FEB04
         MVC   OUTLINE(L'MSG1),MSG1  copy error message       CFK*SEP00
         MVC   OUTLINE+L'MSG1+1(MSG1LN2),0(R1) + rest of msg  CFK*FEB04
         L     R15,PRINT4         get @ PRINTA csect          CFK*SEP03
         LR    R1,R3              get @ print line            CFK*DEC03
         BASR  R14,R15            call PRINTA                 CFK*SEP03
         B     NOTRLDS            and carry on                CFK*SEP00
ADDDS    DS    0H                                             CFK*SEP00
         MVC   OUTINSTR(2),DS4    set up DS                   CFK*JLY00
         CVD   R5,DWC             make length PD              CFK*JLY00
         MVC   OUTOPER(10),=X'202020202020202120E7'   mask+X  CFK*JLY00
         LA    R1,OUTOPER+8       point at last byte          CFK*JLY00
         EDMK  OUTOPER-1(10),DWC+3   make decimal             CFK*JLY00
         MVC   OUTOPER(10),0(R1)  move down length            CFK*JLY00
         MVC   OUTINFO1(11),=C'Trailing DS'                   CFK*SEP01
         L     R15,=V(PRINTP)     get @ PRINTP csect          CFK*DEC03
         LR    R1,R3              get @ print line            CFK*DEC03
         BASR  R14,R15            call PRINTP                 CFK*SEP03
         DROP  R3                 done with @ PA (OUTLINE)    CFK*JLY00
NOTRLDS  DS    0H                                             CFK*JLY00
         MVC   LOC3,ESDLEN3       set current adr. to end of sec *DEC01
         DROP  R6                 done with @ ESDSDMAP        CFK*SEP00
         BAS   R9,AFT             call AFT subroutine         CFK*SEP00
         L     R9,=A(PA)          get @ PA in PASS1 csect     CFK*SEP03
         USING OUTLINE,R9         tell assembler              CFK*SEP00
         CLI   OUTLABEL,C' '      label at this address ?     CFK*SEP00
         BE    ENDLABEL           br. if not                  CFK*SEP00
         MVC   OUTINSTR(3),EQU    put EQU on card             CFK*SEP00
         MVI   OUTOPER,C'*'       put * on card               CFK*SEP00
         L     R15,=V(PRINTP)     get @ PRINTP csect          CFK*DEC03
         LR    R1,R9              get @ print area            CFK*DEC03
         BASR  R14,R15            call PRINTP                 CFK*SEP03
ENDLABEL DS    0H                                             CFK*SEP00
         CLI   ADA,X'FF'          any addresses not processed ? K*SEP00
         BE    NCOL               br. if not                  CFK*SEP00
COLL     DS    0H   loop to handle addresses off end of csect CFK*SEP00
* put ADDR2 onto output                                       CFK*AUG01
         UNPK  OUTADDR2(7),ADAADR(4)   unpack address         CFK*AUG01
         TR    OUTADDR2,=C'0123456789ABCDEF'-240  make chars  CFK*AUG01
         MVI   OUTADDR2+6,C' '    clear gash byte             CFK*AUG01
* put label EQU *+n onto output                               CFK*SEP00
         XR    R3,R3              clear reg                   CFK*SEP00
         ICM   R3,B'0111',LOC3    get current address         CFK*SEP00
         XR    R5,R5              clear reg                   CFK*SEP00
         ICM   R5,B'0111',ADAADR  get labels address          CFK*SEP00
         SR    R5,R3              calc difference             CFK*SEP00
         CVD   R5,DWC             make length PD              CFK*SEP00
         MVC   OUTOPER+2(8),=X'4020202020202120' add EDit maskCFK*SEP00
         LA    R1,OUTOPER+9       point at last byte          CFK*SEP00
         EDMK  OUTOPER+2(8),DWC+4 make decimal                CFK*SEP00
         MVC   OUTOPER+2(8),0(R1) move down length            CFK*SEP00
         MVC   OUTLABEL,ADALABEL  copy label                  CFK*SEP00
         MVC   OUTINSTR(3),EQU    put EQU on card             CFK*SEP00
         MVC   OUTOPER(2),=C'*+'  put *+ on card              CFK*SEP00
         L     R15,=V(PRINTP)     get @ PRINTP csect          CFK*DEC03
         LR    R1,R9              get @ print line            CFK*DEC03
         BASR  R14,R15            call PRINTP                 CFK*SEP03
* get next address                                            CFK*SEP00
         L     R15,BART           FETCH NEXT ADDRESS          CFK*SEP03
         LA    R1,ARTPARMS        get @ parms                 CFK*SEP03
         BASR  R14,R15            call ART csect              CFK*SEP03
         CLI   ADA,X'FF'          any more addresses ?        CFK*SEP00
         BNE   COLL               br. if not
         DROP  R9                 tell asm done with OUTLINE  CFK*SEP00
NCOL     L     R2,=A(PA)          get @ PA in PASS1 csect     CFK*SEP03
* print the Pseudo Registers and Common areas
         USING OUTLINE,R2         tell assembler              CFK*FEB00
         L     R3,NEXT4           get @ NEXT in ESD2 csect
         LR    R4,R3
         LA    R4,4(R4)           get @ first entry
         USING EXTRNMAP,R4        tell assembler              CFK*SEP02
         L     R3,0(R3)           get number of EXTRNs
         SR    R5,R5
         CR    R5,R3              any EXTRNs ?
         BE    NEXE               br if none
ESDC     DS    0H
         CLI   EXTTYPE,EXTTPR     Pseudo Register ?           CFK*MAY03
         BNE   NOTPR              not a common area if not    CFK*MAY03
         MVC   OUTLABEL,EXTNAME   copy area name              CFK*MAY03
         TM    EXTINFO,EXTIIAD    check alignment             CFK*JUN03
         BZ    GENDXD             if byte aligned DXD         CFK*JUN03
         MVC   OUTINSTR,=C'DSECT' else build dsect card       CFK*JUN03
         L     R15,=V(PRINTP)     get @ PRINTP csect          CFK*DEC03
         LR    R1,R2              get @ print line            CFK*DEC03
         BASR  R14,R15            call PRINTP                 CFK*SEP03
* If we have SYM data the dsect will already be defined so    CFK*JUN03
* we need to get back to the start of it, then pad to full    CFK*JUN03
* length with a DS.                                           CFK*JUN03
         MVC   OUTINSTR(3),=C'ORG'  get back to start         CFK*JUN03
         MVC   OUTOPER(8),EXTNAME    of dsect                 CFK*JUN03
         B     PRTORG             and go to print it          CFK*JUN03
GENDXD   DS    0H                                             CFK*JUN03
         MVC   OUTINSTR(3),=C'DXD'  else ind. DXD             CFK*MAY03
         B     SETPRLEN           and go to set length        CFK*MAY03
NOTPR    DS    0H                                             CFK*MAY03
         CLI   EXTTYPE,EXTTCM     common area ?               CFK*MAY03
         BNE   NEXBE              not a common area if not    CFK*MAY03
         MVC   OUTINSTR(3),COM4   copy c'COM'
         MVC   OUTLABEL,EXTNAME   copy common area name
PRTORG   DS    0H                                             CFK*JUN03
         L     R15,=V(PRINTP)     get @ PRINTP csect          CFK*DEC03
         LR    R1,R2              get @ print line            CFK*DEC03
         BASR  R14,R15            call PRINTP                 CFK*SEP03
         MVC   OUTINSTR(2),DS4    copy c'DS'
SETPRLEN DS    0H        set Common or PR length              CFK*MAY03
         SR    R5,R5                                          CFK*MAY03
         ICM   R5,B'0111',EXTCMLEN  get common area length    CFK*MAY03
         CVD   R5,DWC             make it PD
         MVC   OUTOPER(8),=X'4020202020202120' add EDit mask  CFK*MAY03
         LA    R1,OUTOPER+7       point at last byte          CFK*MAY03
         MVI   OUTOPER+8,C'C'     add C
         EDMK  OUTOPER(8),DWC+4   make decimal                CFK*MAY03
         MVC   OUTOPER(9),0(R1)   move down length            CFK*MAY03
         CLI   EXTNAME,C' '       was common name blank ?     CFK*MAY03
         BNE   PCM                br. if not
         MVI   OUTLABEL,C'B'      else set name to B00000
         MVC   OUTLABEL+1(5),BZ5  copy c'00000'
PCM      L     R15,=V(PRINTP)     get @ PRINTP csect          CFK*DEC03
         LR    R1,R2              get @ print area            CFK*DEC03
         BASR  R14,R15            call PRINTP                 CFK*SEP03
NEXBE    DS    0H                                             CFK*MAY03
         LA    R4,EXTNEXT         get @ next entry in EXTRN table MAY03
         BCT   R3,ESDC            loop if more EXTRNs to check
         DROP  R4                 tell asm done with EXTRNMAP CFK*SEP02
         DROP  R2                 tell asm done with OUTLINE  CFK*FEB00
NEXE     DS    0H
* code to print using table deleted from here                 CFK*SEP00
         MVI   PAS45,X'FF'        flag not 2nd use of PASS4
         MVI   EXTPRTD,x'00'      clear EXTRNs printed flag   CFK*JAN04
         L     R3,COTR4           get @ COTR csect
         MVI   2(R3),X'00'        clear control flag
         L     R14,=A(SVK)        get @ flag in SAVA          CFK*DEC01
         MVI   0(R14),X'00'       clear 2nd pass flag         CFK*DEC01
Z99X     DS    0H                 exit point                  CFK*NOV01
         L     R3,=A(PA)          PRINT END                   CFK*SEP03
         USING OUTLINE,R3         tell assembler              CFK*DEC01
         MVC   OUTINSTR(3),ENDF4  copy c'END '                CFK*DEC01
         L     R15,=V(PRINTP)     get @ PRINTP csect          CFK*DEC03
         LR    R1,R3              get @ print line            CFK*DEC03
         BASR  R14,R15            call PRINTP                 CFK*SEP03
         DROP  R3                 tell asm done with OUTLINE  CFK*DEC01
         LEAVE ,                  STOP                        CFK*SEP03
* this code only executed on the 2nd pass, ie 1st use of PASS4
EPS2     MVI   PAS45,X'00'        flag 2nd use of PASS4
         SR    R3,R3              ) clear KEY4
         ST    R3,KEY4            )  (FTXT parm)
         LEAVE ,                  return to PASS0             CFK*SEP03
* 2nd and 4th pass code
LFTXT5   MVC   FMTLOC3,LOC3       copy current address
         MVC   FMTFL1,INST4+8     copy AXNFLG1
         MVC   LEN4(4),KEY4+4     copy instruction length
         MVC   RT4(8),INST4       copy instruction TEXT
         L     R15,ROUT4          get @ format routine        CFK*NOV03
RF5      DS    0H                                             CFK*NOV03
         LA    R1,FMTPRM          get @ parameters            CFK*NOV03
         BASR  R14,R15            call format routine         CFK*NOV03
         CLI   SIN,X'01'
         BE    GONE
         MVC   FPTL(8),KEY4       copy FTXT output to SPPR parms
         MVC   FPTL+8(12),INST4   copy FTXT output to SPPR parms
         MVC   FPTL+20(8),LEN4    copy instruction length to SPPR
         MVC   FPTL+28(4),ROUT4   pass @ decoding routine to SPPR
         CLC   RT4(4),IMM         is instruction TXT C'IMM=' ?
         BNE   SPRT               branch if not
         MVI   SIN,X'01'
         MVI   KEY4+3,X'02'
         MVI   FPTL+3,X'02'
SPRT     L     R15,ASPPR          get @ SPPR csect            CFK*SEP03
         LA    R1,FPTL            get @ SPPR parms            CFK*SEP03
         BASR  R14,R15            call SPPR                   CFK*SEP03
         MVC   KEY4(8),FPTL
         MVC   LEN4(4),FPTL+20
         CLI   FPTL+28,X'01'
         BE    LFTXT4             loop back
         CLI   FPTL+28,X'02'
         BNE   GONE
         L     R15,ROUTC           get @ CONST csect
         ST    R15,ROUT4
         B     RF5                go back to call CONST
GONE     LA    R14,RETD           set return adr for DECOMP   CFK*SEP03
         MVC   PAR+1(3),LOC3      setup DECOMP
         MVC   PAR+4(8),INST4      parms
         MVC   PAR+12(4),ONE      copy f'1'
         CLC   ROUT4(4),ACONST    is it @ CONST csect ?
         BNE   CARL
         XC    PAR+12(4),PAR+12   clear DECOMP parms
         B     BDCM
CARL     CLC   ROUT4(4),AARL      rout4 = @ ARL csect ?
         BNE   BDCM
         MVC   PAR+12(4),X84      copy x'84000000'
         L     R1,ASBCZ           get @ SBCZ in ARL csect
         CLI   0(R1),X'FF'        EXTRN present ?
         BE    BDCM               NO, skip copy
         MVC   PAR+13(3),ASBCZ+1  copy @ SBCZ in ARL csect
BDCM     L     R15,ADECO          get @ DECOMP csect
         CNOP  2,4
         BALR  R1,R15             call DECOMP
PAR      DC    6F'0'
RETD     CLI   PAS45,X'FF'        2nd use of PASS4 ?
         BE    LFTXT4             loop back if not
*** DECOMP has the following code
*DECO     TITLE 'DECOMP DUMMY'
*DECOMP   CSECT
*         USING *,15
*         L     15,20(1)
*         BR    14                                            CFK*SEP03
*         END
*** end of DECOMP code
* 4th pass only code
         L     R3,=A(PA)          get @ PA in PASS1 csect     CFK*SEP03
         USING OUTLINE,R3         tell assembler              CFK*FEB00
         CLI   OUTINSTR,C' '      anything to print ?
         BE    LSPK               br if not
         L     R4,LNCT            get LINE COUNT
         LA    R4,1(R4)           add 1
         ST    R4,LNCT            save new line count
         MVC   OUTSTMT,NED        copy EDit mask
         CVD   R4,DLC             make line count decimal
         ED    OUTSTMT,DLC+5      add line count to listing
         L     R15,=V(PRINTP)     get @ PRINTP csect          CFK*DEC03
         LR    R1,R3              get @ print area            CFK*DEC03
         BASR  R14,R15            call PRINTP                 CFK*SEP03
         DROP  R3                 tell asm done with OUTLINE  CFK*FEB00
LSPK     L     R3,=A(PAB)         get @ PAB in PASS1 csect
         CLI   0(R3),X'FF'        IS SECOND LINE
         BNE   LFTXT4             TO BE PRINTED
         CLI   3(R3),C' '         YES
         BE    LPA4
         MVI   0(R3),C' '
         MVC   CD5+3(5),3(R3)     pass number to CDN
         L     R14,ACDN           CONVERT TO HEX
         ST    R13,CD5R13         put R13 where CDN expects   CFK*SEP03
         CNOP  2,4
         BALR  R14,R14            call CDN csect
CD5      DC    C'0000'            ) BCD number to
         DC    F'0'               )  convert to binary number
CD5R13   DC    F'0'               R13 (re)loaded from here
         L     R3,=A(PAB)         get @ PAB in PASS1 csect
         MVC   LOC3,CD5+5         set current address
         BAL   R9,AFT             call AFT subroutine
LPA4     L     R4,=A(PA)          get @ PA in PASS1 csect     CFK*SEP03
         L     R3,=A(PAB)         get @ PAB in PASS1 csect    CFK*SEP03
         MVC   55(8,R3),55(R4)    copy label
         MVC   1(90,R4),0(R4)     clear PA
         MVI   0(R3),C' '
         L     R4,LNCT            get line count
         LA    R4,1(R4)           add 1
         ST    R4,LNCT            save new line count
         MVC   47(6,R3),NED       copy EDit mask
         CVD   R4,DLC             make line count decimal
         ED    47(6,R3),DLC+5     add line count to listing
         L     R15,=V(PRINTP)     PRINT A LINE                CFK*DEC03
         LR    R1,R3              get @ print area            CFK*DEC03
         BASR  R14,R15            call PRINTP                 CFK*SEP03
         B     LFTXT4             loop back
         USING OUTLINE,R3         tell assembler              CFK*FEB00
MVQQ     MVC   77(1,R3),0(R4)     EXecuted instruction
         DROP  R3                 done with OUTLINE           CFK*FEB00
IMM      DC    C'IMM='            mark start of constant area
         LTORG                                                CFK*DEC02
HUD      DC    F'99'                size of equate table
FF94     DC    F'59'                constant
COTR4    DC    A(COTR)              @ COTR csect
ALCT4    DC    A(LCT)               @ LCT in PRINTA csect
DRT      DC    D'0'
DLC      DC    D'0'
LNCT     DC    F'0'                 line count
AFTXTA   DC    A(FTXTA)             @ FTXTA csect             CFK*SEP03
STW4     DC    F'1'                 not used ?
SEV4     DC    F'7'                 constant
FZ4      DC    X'000004'            constant
PRINT4   DC    A(PRINTA)            @ PRINTA csect            CFK*SEP03
NPROGA   DC    A(NPROG)             @ NPROG in ESD0 csect     CFK*JAN00
ACURRSEC DC    A(CURRSECT)          @ current section desc.   CFK*JLY00
US4      DC    A(USING)             @ USING csect
ASPPR    DC    A(SPPR)              @ SPPR csect
APLCB    DC    A(PLCB)              @ PLCB in SPPR csect
NED      DC    X'402020202121'      EDit mask for line count
ENDF4    DC    C'END '              constant
BART     DC    A(ART)               @ ART csect
XSX      DC    F'96'
B15      DC    F'0'
ZZ4      DC    F'0'                 constant
DLC4     DC    D'0'
RGL4     DC    F'0'
EQU      DC    C'EQU '              constant
AFTA     DC    F'0'                 USST and AFT save return adr. here
ALCOM4   DC    A(LCOM)              @ LCOM in ESD5 csect
MSG1     DS    0CL(MSG1LN1)                                   CFK*FEB04
MSG1A    DC    C'**  TXT extends off end of section '         CFK*FEB04
MSG1I1   DC    CL8'XXXXXXXX'        section name              CFK*FEB04
         DC    C' by'                                         CFK*FEB04
MSG1LN1  EQU   *-MSG1A              length of fixed len part  CFK*FEB04
MSG1I2   DC    C' nnn,nnn,nnn'                                CFK*FEB04
MSG1B    DC    C' bytes'                                      CFK*FEB04
MSG1LN2  EQU   *-MSG1I2             length of var len part    CFK*FEB04
         DC    C'            '      padding                   CFK*FEB04
ADB      DC    F'0'
FT08     DC    X'000008'            constant
ADBC     DC    F'0'                 not used ?
EXTRN    DC    C'EXTRN'             constant
ENTRY    DC    C'ENTRY'             constant
CSECT    DC    C'CSECT'             constant
RMODEANY DC    C'RMODE ANY'         constant                  CFK*JAN00
AMODEANY DC    C'AMODE ANY'         constant                  CFK*JAN00
SPACES   DC    CL8' '               constant                  CFK*APR00
NENT4    DC    A(NENT)              @ NENT in ESD1 csect
NEXT4    DC    A(NEXT)              @ NEXT in ESD2 csect
AENDA    DC    A(ENDA)              @ ENDA in TXT csect
FFBR     DC    X'90ECD00C'          constant, STM  14,12,12(13)
SKY      DC    F'0'                 flag
BRT      DC    F'0'                 save r3 during USST/USING call
ACDN     DC    A(CDN)               @ CDN csect
ROUTC    DC    A(CONST)             @ CONST csect
ASAVC    DC    A(SAVA)              @ SAVA csect
BCV4     DC    A(BCV)               @ BCV csect
USI4     DC    C'USING '            constant
COM4     DC    C'COM '              constant
DS4      DC    C'DS  '              constant
NXSX     DC    F'60'                constant
SIN      DC    F'0'
FEH      DC    X'9847'              constant
COAD     DC    X'FFFFFF00'          constant
DSA      DC    F'0'
DWC      DC    D'0'
DW4      DC    F'0'
BC       DC    F'0'
BZ5      DC    C'00000'             constant
F100     DC    F'4096'              constant
COBR     DC    F'0'
PLC      DC    F'0'                 ) these
COBRG    DC    F'48'                )  fields
COBA     DC    F'0'                 )   copied
ACT      DC    F'0'                 )    into
COBF     DC    F'0'                 )     PLCB
FFAD     DC    F'0'                 )      in
FFC      DC    F'0'                 )       SPPR
FORHF    DC    F'0'                 )        csect
PAS45    DC    X'FF000000'          ) flags, 1st byte made x'00' to
*                                     indicate the 2nd use of PASS4
EXTPRTD  EQU   PAS45+1,1              flag, EXTRNs printed    CFK*DEC02
ACONST   DC    A(CONST)             @ CONST csect
AARL     DC    A(ARL)               @ ARL csect
ADECO    DC    A(DECOMP)            @ DECOMP csect
ONE      DC    F'1'                 constant
X84      DC    X'84000000'          constant
ASBCZ    DC    A(SBCZ)              @ SBCZ in ARL csect
NUMSECT  DS    F                    number of sections        CFK*FEB03
* parms to call ART                                           CFK*SEP03
ARTPARMS DS    0CL12                                          CFK*SEP03
ADA      DC    F'0'               entry point, ref'ed by CONST FK*SEP03
ADAADR   EQU   ADA+1,3            3 byte address of label     CFK*SEP03
ADALABEL DS    CL8                8 byte label at this address FK*SEP03
* end of ART parms                                            CFK*SEP03
* parms to call format routines                               CFK*NOV03
FMTPRM   DC    A(PA)              @ PA in PASS1 csect         CFK*NOV03
LEN4     DC    F'0'               instruction length          CFK*NOV03
RT4      DC    XL8'00'            instruction TEXT            CFK*NOV03
FMTLOC3  DC    XL3'00'            3 byte IC                   CFK*NOV03
FMTFL1   DC    X'00'              copy of AXNFLG1             CFK*NOV03
* end of format routine parms                                 CFK*NOV03
* parms to call SAVA                                          CFK*SEP03
SAVPARMS DS    0XL20                                          CFK*SEP03
SAVTYPE  DC    X'00'             type of address
SAVASECT DS    CL8               csect label is in            CFK*DEC03
SAVADR   DC    XL3'00'           address to save
SAVOUTLB DS    0CL8              output label                 CFK*MAY00
SAVNAME  DC    CL8' '            label at this address        CFK*APR00
* end of SAVA parms
*  USING parms are:
*    +0  hex flag, 00 - drop, 01 or 02 - insert, 03 - retrieve
*    +2  1 byte address part of instruction
*    +3  1 byte address part of instruction
*    +4  3 byte current loc (?) - if insert
*    +7  1 byte instruction format from AXN table
* parms to call USING                                         CFK*SEP03
USINGPRM DS    0XL8                                           CFK*SEP03
USFLAG   DC    X'0'              flag byte                    CFK*SEP03
         DS    X                 not used ?                   CFK*SEP03
USADR1   DS    X                                              CFK*SEP03
USADR2   DS    X                                              CFK*SEP03
USLOC    DS    XL3               current location (inserts)   CFK*SEP03
USFMT    DS    X                 instr format                 CFK*SEP03
* end of USING parms                                          CFK*SEP03
* parms to call FTXTA                                         CFK*SEP03
FTXTAPRM DS    0F                                             CFK*SEP03
         DC    A(PA)              @ PA in PASS1 csect
KEY4     DC    F'0'               flag, set to F'1' at end of last card
         DC    X'0'               copy of AXNFMT for instr
         DC    X'0'               copy of AXNOPER for instr
LEN2     DC    H'0'               halfword length of instruction found
ROUT4    DC    A(CKEN)            output @ decoding routine   CFK*JUN01
INST4    DC    2F'0'              output TEXT of instruction/constant
LOC4     DC    F'0'               output AXNFLG1 + current address
LOC3     EQU   LOC4+1,3           output, current address     CFK*JAN00
         DC    F'0'
* end of FTXTA parms                                          CFK*SEP03
* parms to call SPPR                                          CFK*SEP03
FPTL     DC    8F'0'
         DC    F'0'
* end of SPPR parms                                           CFK*SEP03
SAVEAREA DS    18F                save area                   CFK*SEP03
PAC      DC    CL133' '             3rd print buffer, for AFT CFK*SEP00
         YREGS                      register equates          CFK*JLY00
         END
