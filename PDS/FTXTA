FTXA     TITLE '*** F T X T A ***  (REVISED && STANDARDIZED FTXT)  '
***********************************************************************
*                                                                     *
* Called by PASS4 via FTXT.                                           *
*                                                                     *
* Parms @ r1:                                                         *
*   +0 - @ print area in PASS1.                                       *
*   +4 - KEY4, flag set to f'1' when end of last card reached.        *
*   +8 - output instruction format (copy of AXNFMT).                  *
*   +9 - output operand format (copy of AXNOPER).                     *
*   +10 - output length of instruction/constant.                      *
*   +12 - ROUT4, output @ decoding routine.                           *
*   +16 - INST4, output 8 bytes TEXT of instruction/constant.         *
*   +24 - output copy of AXNFLG1.                                     *
*   +25 - output 3 byte instruction counter.                          *
*   +28 - ?                                                           *
*   +32 - return to here.                                             *
*                                                                     *
* History:                                                            *
*   AXN parms changed to support 2 byte opcodes, 5 byte   CFK May 1999*
*       mnemonics and separate opcode and operand formats.            *
*   Pass 1st 4 bytes on instr. to AXN, not 1st 2 bytes.   CFK Jun 1999*
*   Pass opcode and operand formats to PASS4 in parm.     CFK Jun 1999*
*       bytes 8 and 9. Output length now 2 bytes.                     *
*   Use symbolic addressing for the opcode table.         CFK Feb 2000*
*   Map output line with OUTLINE macro.                   CFK Mar 2000*
*   Call INFO instead of TIME.                            CFK Apr 2000*
*   Call AXN with standard linkage conventions.           CFK Apr 2000*
*   Use equates for all registers.                        CFK Apr 2000*
*   Map parms with PRMDUM DSECT.                          CFK Apr 2000*
*   Use R10 as pointer to parms.                          CFK Apr 2000*
*   Call CRLD with standard linkage conventions.          CFK Dec 2000*
*   TXT pointers moved to ESD descriptors.                CFK May 2001*
*   Map TXT headers with TXTHDR macro.                    CFK May 2001*
*   Handle ZOBS before a DS correctly.                    CFK Jun 2001*
*   Group constants before variables.                     CFK Jly 2001*
*   Simplify code to put address on listing.              CFK Jly 2001*
*   Correct check for end of current card.                CFK Aug 2001*
*   Return from ZOBS if RLD in 1st 8 bytes.               CFK Sep 2001*
*   Set start address to start of section (may be DS).    CFK Jan 2002*
*   Correctly process leading DS.                         CFK Sep 2002*
*   Only reset RLF in CRLD at end of section.             CFK Apr 2003*
*   Pass RLD flag byte back when RLD found.               CFK Jun 2003*
*                                                                     *
***********************************************************************
         SPACE 2
         ESDSDMAP              map ESD table entry            CFK*MAR00
         SPACE 2
         OUTLINE                  map output line             CFK*MAR00
         SPACE 2
         TXTHDR                   map TXT headers             CFK*MAY01
         SPACE 2
         RLDITEM                  map RLD item                CFK*JUN03
         SPACE 2
***********************************************************************
*                                                                     *
*  DSECT to map the parameters passed to FTXTA                        *
*                                                                     *
***********************************************************************
PRMDUM   DSECT
PRM@PA   DS    A     +0 - @ print area in PASS1
PRMKEY4  DS    A     +4 - KEY4, flag?
PRMFMT   DS    X     +8 - output instruction format (copy of AXNFMT)
PRMOPER  DS    X     +9 - output operand format (copy of AXNOPER)
PRMLEN   DS    H    +10 - output length of instruction/constant
PRMROUT4 DS    A    +12 - ROUT4, output @ decoding routine
PRMINST4 DS    XL8  +16 - INST4, output 8 bytes TEXT of instr/constant
PRMFLG1  DS    X    +24 - output copy of AXNFLG1
PRMIC    DS    XL3  +25 - output 3 byte instruction counter
         DS    XL4  +28 - ?
PRMRET   DS    0H   +32 - return to here
          SPACE 2
***********************************************************************
*                                                                     *
*  DSECT to map the opcode table at FTBL                              *
*                                                                     *
***********************************************************************
TBLD     DSECT
TBLFLG   DS    X               Flag byte, copy of AXNFLG
*  the high 4 bits are the instruction format as follows
*  the low 4 bits depend on the instruction format as follows
*BLFCON  EQU   0                 Constant
*BLFRR   EQU   1                 RR - R1,R1
*              11                   - F1,F2 (short)
*              12                   - F1,F2 (long)
*              13                   - R1
*              1F                 terminating instruction.
*BLFRX   EQU   2                 RX - R1,D2(X2,B2)
*              20      references byte or no memory access
*              21          "      Halfword
*              22          "      signed Fullword
*              23          "      Doubleword
*              24          "      short Float
*              26          "      Fullword
*              27          "      unsigned Fullword
*              28          "      long Float (unnormalised)
*              2F                 terminating instruction
*BLFRS   EQU   3                 RS - R1,R3,D2(B2)
*              31                   - R1,D2(B2)
*              3F                 terminating instruction
*BLFSI   EQU   4                 SI - D1(B1),I2
*              41                   - D1(B1)
*              4F                 terminating instruction
*BLFSS   EQU   5                 SS - 1 length, D1(L,B1),D2(B2)
*              51                SS - 2 lengths, D1(L1,B1),D2(L2,B2)
*BLADCON EQU   X'6E'             Address Constant
*BLDS    EQU   X'7E'             DS
*BLZOB   EQU   X'8E'             Zeroes Or Blanks
TBLADR   DS    XL3             address of this instruction
TBLADRLB EQU   TBLADR+2,1       low byte of address
TBLID    DS    X               entry ID, 0 - 15
TBLDISP  DS    X               displacement into current TXT card
TBLOPLEN DS    H               Length of this instruction/DS/Adcon
TBLENTLN EQU   *-TBLD          Length of one entry.
*
FTXTA    CSECT
         ENTRY COFST              ref'ed by ARL
         ENTRY RFTXT              ref'ed by SPPR
         EXTRN ARL                csect
         EXTRN AXN                csect
         EXTRN CONST              csect
         EXTRN CRLD               csect
         EXTRN CURRSECT           in ESD0 csect, @ curr. sect CFK*MAY01
         EXTRN PA                 in PASS1 csect              CFK*APR00
         EXTRN PAB                in PASS1 csect
         EXTRN PR                 csect
         EXTRN RR                 csect
         EXTRN RS                 csect
         EXTRN RX                 csect
         EXTRN SI                 csect
         EXTRN SS                 csect
         EXTRN DS                 csect
         EXTRN RLF                in CRLD csect               CFK*APR03
         EXTRN INFO               csect                       CFK*APR00
         STM   R14,R12,12(R13)    **************
         BALR  R12,0              *            *
         USING *,R12              *  STANDARD  *
         ST    R13,SAVE+4         *   S/360    *
         LR    R11,R13            *  LINKAGE   *
         LA    R13,SAVE           *            *
         ST    R13,8(R11)         **************
         LR    R10,R1             copy @ parms                CFK*APR00
         USING PRMDUM,R10         tell assembler about parms  CFK*APR00
         CLI   FPFLG,X'FF'        IS THIS FIRST PASS?
         BE    INTL               BRANCH IF YES
         CLI   PCFLG,X'FF'        IS PROCESS FLAG ON?
         BNE   LKAHD              BRANCH IF NO
         B     PROCS              else go to process routine
         TITLE '*** I N I T I A L I Z A T I O N ***  (LKAHD && PROCS)'
INTL     MVI   FPFLG,X'00'        TURN-OFF FIRST PASS FLAG
*        XC    TOTA(4),TOTA
         L     R7,HITBL           *********************
         LA    R7,1(R7)
         LA    R6,FTBL+4          *                   *
         SR    R5,R5              * PLACE TABLE ENTRY *
         ST    R5,0(R6)           * I.D. NUMBERS IN   *
AGNA     LA    R6,8(R6)           * BYTE 4 OF EACH    *
         LA    R5,256(R5)         * TABLE ENTRY       *
         STH   R5,0(R6)           *                   *
         BCT   R7,AGNA            *********************
         LA    TBL,FTBL           SET TABLE TO ENTRY ZERO
         USING TBLD,TBL           tell assembler              CFK*FEB00
         MVI   TBLFLG,X'0F'       TERMINAL CODE INTO BO
         L     R5,=A(CURRSECT)    get @ current section ptr   CFK*MAY01
         L     R5,0(R5)           get @ current section desc  CFK*MAY01
         USING ESDSDMAP,R5        tell assembler              CFK*MAY01
         MVC   TNTC(4),ESDNTXT    TOTAL NUMBER OF TXT CARDS   CFK*MAY01
         MVC   CRLDID,ESDID       copy current section ID     CFK*DEC01
         L     R3,TNTC            get number of TXT cards
         BCTR  R3,0               subtract 1
         ST    R3,TNT1            save it
         L     R3,ESDCBUF         get @ first TXT header      CFK*MAY01
         USING TXTHDR,R3          tell assembler              CFK*MAY01
         MVC   TBLADR,ESDADR3     FIRST LOGICAL ADR TO B13    CFK*JAN02
         MVC   SAVSDADR,ESDADR    save section address        CFK*APR02
         ST    R3,CATXB           SET TXTB POINTER TO TXTB ADR
         L     R5,ESDTBUF         SET TEXT POINTER TO         CFK*MAY01
         DROP  R5                 was ESDSDMAP                CFK*MAY01
         ST    R5,SATXS           FIRST BYTE OF TEXT
         ST    R5,SAVTXPTR        @ save @ first byte of TXT  CFK*MAY01
         CLC   TXTHADR,TBLADR     does section start with DS? CFK*SEP02
         BE    NO1STDS            branch if not               CFK*JAN02
         BL    *+1                txt before start of section CFK*SEP02
         SR    R14,R14             )                          CFK*JAN02
         ICM   R14,B'0111',TXTHADR ) calculate                CFK*SEP02
         SR    R15,R15             )  DS                      CFK*SEP02
         ICM   R15,B'0111',TBLADR  )   length                 CFK*SEP02
         SR    R14,R15             )                          CFK*SEP02
         MVC   TBLADR,TXTHADR     put txt adr in first slot   CFK*DEC02
         LA    TBL,TBLENTLN(TBL)  ) build DS                  CFK*DEC02
         MVC   TBLADR,SAVSDADR+1  )  entry                    CFK*DEC02
         STH   R14,TBLOPLEN       )   in                      CFK*JAN02
         MVI   TBLFLG,X'7E'       )    2nd slot               CFK*JAN02
         MVC   TBLADR+TBLENTLN,TBLADR  copy I.C. to next slot CFK*NOV02
         MVI   TBLDISP+TBLENTLN,X'00'  zero text pointer disp CFK*NOV02
         ST    TBL,CATBL          save @ current table entry  CFK*NOV02
NO1STDS  DS    0H                                             CFK*JAN02
         SR    R14,R14             ) calculate                CFK*AUG01
         ICM   R14,B'0111',TXTHADR )  @ first                 CFK*AUG01
         SR    R5,R5               )   byte after             CFK*AUG01
         IC    R5,TXTHLEN          )    current               CFK*AUG01
         AR    R14,R5              )     card                 CFK*AUG01
         ST    R14,EOC             save it for reuse          CFK*AUG01
         BAL   R14,ADCON          GET FIRST ADCON LOGICAL ADR
         MVC   NBLC+3(1),TXTHLEN  NO. OF BYTES LEFT ON CARD
         CLI   TBLFLG,X'7E'       initial DS present ?        CFK*SEP02
         BE    PROCS              if so go and process it     CFK*NOV02
         DROP  R3                 was TXTHDR                  CFK*APR02
         TITLE '*** L O O K A H E A D *** '
LKAHD    LA    TBL,FTBL           SET TABLE POINTER TO ENTRY ZERO
         L     R3,CATXB           get @ current TXTB entry
         USING TXTHDR,R3          tell assembler              CFK*APR02
         MVI   PCFLG,X'FF'        RESET PROCESS FLAG
         MVC   TBLADR+TBLENTLN,TBLADR  PLACE I.C. IN B13 OF ENTRY ONE
         MVI   TBLDISP+TBLENTLN,X'00'  ZERO TEXT POINTER DISPLACEMENT
GOAGN    CLC   TBLID,HITBL+3      HAS HIGHEST TABLE ENTRY BEEN REACHED?
         BNL   TERME              BRANCH IF YES
         CLI   TFL,X'FF'          end of LAST CARD ?          CFK*AUG01
         BE    TERME              br. if yes                  CFK*AUG01
         CLI   TBLID,X'0E'        entry 14 ?
         BNE   NCP                br. if not
         CLI   TBLFLG,X'00'       constant ?
         BNE   NCP                br. if not
         TM    TBLADRLB,X'02'     on an odd halfword ?
         BO    NCP                branch if yes
         CLC   TBLOPLEN,FOUR+2    4 byte opcode ?
         BE    TERME              branch if so
NCP      LA    TBL,TBLENTLN(TBL)  SET POINTER TO NEXT ENTRY
         TM    TBLADRLB,X'01'     IS I.C. ON HW BOUNDARY?
         BZ    EVEN               BRANCH IF YES
         MVI   TBLFLG,X'00'       CLASSIFY AS CONSTANT
         MVC   TBLOPLEN,ONE1+2    OF LENGTH ONE
         B     CNST               GO TO CONSTANT ROUTINE
EVEN     SR    R5,R5              MOVE THE
         IC    R5,TBLDISP         NEXT OP
         A     R5,SATXS           CODE TO
*        S     R5,SAVSDADR         (- section offset)         CFK*JAN04
         MVC   AOP1(6),0(R5)      AXN AREA
         MVC   CC(1),1(R5)        copy 2nd byte of opcode
         TM    AOP1,X'BF'         IS OP CODE A ZERO OR A BLANK?
         BNZ   NZOB               BRANCH IF NO
         TM    TBLADRLB,X'02'     on a fullword boundary ?
         BO    NZOB               branch if not
         ST    R5,AZBTS           SAVE TXTS POINTER
         CLI   AOP1,X'00'         IS OP CODE ZERO?
         BNE   NZERO              BRANCH IF NO
         CLC   0(8,R5),ZEROS      IS TEXT EIGHT BYTES OF ZEROES?
         BNE   NZOB               BRANCH IF NO
         LA    R6,ZEROS           ADR OF ZEROS
CZOBS    ST    R6,ADRZB           SAVE TYPE ADR
         B     ZOBS               GO TO 'ZOBS'
NZERO    CLC   0(8,R5),BLANK      IS TEXT EIGHT BYTES OF BLANKS?
         BNE   NZOB               BRANCH IF NO
         LA    R6,BLANK           ADR OF BLANKS
         B     CZOBS              GO TO CALL 'ZOBS'
NZOB     BAL   R14,CLAXN          CALL AXN VIA CAXN INTERFACE
         MVI   TBLFLG,X'00'       assume constant
         CLC   0(4,R5),BLANK      is text 4 bytes of blanks ?
         BE    REDO               treat as constant if so
         MVC   TBLFLG,AOP4        AXN CODE TO BO
REDO     MVC   TBLOPLEN,TWO2+2    MAKE LENGTH CODE TWO
         TM    TBLFLG,X'70'       TEST CLASSIFICATION
         BZ    CNST               BRANCH IF CONSTANT
         BM    INSTR              BRANCH IF INSTRUCTION
         ABEND 20,DUMP            DUMP, ILLEGAL AXN CODE
         TITLE '*** C O N S T A N T *** '
CNST     SR    R5,R5
         IC    R5,TBLDISP         PUT NEW TEXT ADR DIS-
         AH    R5,TBLOPLEN        PLACEMENT INTO B5 OF
         STC   R5,TBLDISP+TBLENTLN    NEXT TABLE ENTRY
         ICM   R5,B'0111',TBLADR  get current address         CFK*AUG01
         AH    R5,TBLOPLEN        add entry length            CFK*AUG01
         C     R5,EOC             TXT CARD BOUNDARY CROSSED?  CFK*AUG01
         BH    BDS                yes -  check for 'DS'
         BL    NODSA              no - can't be a 'DS'
         CLC   NTCF(4),TNT1       all cards fetched ?
         BL    NODSA              br. if more cards to fetch
         OI    TFL,X'01'          set end of last card flag   CFK*SEP01
         B     NODSA              and skip call to DS check routine
BDS      BAL   R14,DSCK           CALL 'DS' CHECK ROUTINE
         B     CNST               and try again
NODSA    L     R5,TBLADR-1          FORM
         AH    R5,TBLOPLEN           NEXT
         ST    R5,TBLADR-1+TBLENTLN   I.C.
         CLC   TBLADR+TBLENTLN,ARLD+1    HAS RLD ENTRY BEEN REACHED?
         BH    FRLD               BRANCH IF YES
         CLI   TBLID,X'01'         IS THIS THE FIRST TABLE POSITION
         BE    GOAGN              BRANCH IF YES
         LR    R5,TBL             IS THE PRECEEDING
         S     R5,EIGHT           CLASSIFICATION A
         CLI   0(R5),X'00'        NON-TERM CONSTANT?
         BNE   IFBC               BRANCH IF NO
         TM    TBLADRLB,X'03'     IS I.C. ON FW BOUNDARY?
         BZ    GOAGN              BRANCH IF YES
         MVC   AOP1(4),0(R5)       FETCH POTENTIAL OP CODE    CFK*jun99
         BAL   R14,CLAXN           DETERMINE IF OP CODE
         LA    TBL,TBLENTLN(TBL)   UPDATE TABLE POINTER
         CLI   AOP4,X'00'         IS IT AN INSTRUCTION ?
         BNE   GOAGN               BRANCH IF IT IS
         LR    TBL,R5             MOVE TABLE POINTER BACK ONE ENTRY
         LH    R5,TBLOPLEN        UPDATE LENGTH
         LA    R5,2(R5)           BY TWO FOR
         STH   R5,TBLOPLEN        CONSTANT
         SR    R5,R5               ZERO REGISTER
         IC    R5,TBLDISP          INSERT DISPLACEMENT
         AH    R5,TBLOPLEN         ADD INSTRUCTION LENGTH
         STC   R5,TBLDISP+TBLENTLN   STORE DISPL IN NEXT TABLE ENTRY
         L     R5,TBLADR-1+TBLENTLN   LOAD IC
         LA    R5,2(R5)               UPDATE IC
         ST    R5,TBLADR-1+TBLENTLN   SAVE CALC IC
         B     GOAGN
         TITLE '*** I N S T R U C T I O N *** '
INSTR    CLI   TBLID,X'08'        eighth entry ?
         BL    INSTRS             branch if less
         LR    R5,TBL             get @ previous
         S     R5,EIGHT            table entry
         CLI   TBLID,X'01'        on the 2nd entry ?
         BE    INSTRS             branch if yes
         CLI   0(R5),X'00'        was prev entry a constant ?
         BNE   INSTRS             branch if not
         TM    TBLADRLB,X'02'     are we on a fullword boundary ?
         BZ    LRG                branch if yes
         S     R5,EIGHT           subtract 8
LRG      LR    TBL,R5             go back to prev entry or before
         B     TERME
INSTRS   LH    R5,TBLOPLEN        *********************
         TM    AOP1,X'C0'         *                   *
         BZ    ILEN2              * FIND INSTR LENGTH *
         BM    ILEN4              * AND PLACE IN B67  *
         LA    R5,2(R5)           * OF CURRENT ENTRY  *
ILEN4    LA    R5,2(R5)           *                   *
         STH   R5,TBLOPLEN        *********************
ILEN2    L     R6,TBLADR-1        FORM
         AR    R6,R5              NEXT
         ST    R6,TBLADR-1+TBLENTLN   I.C.
         CLC   TBLADR+TBLENTLN,ARLD+1    HAS RLD ENTRY BEEN REACHED?
         BH    FRLD               BRANCH IF YES
         AH    R5,TBLID           PLACE NEW TEXT ADR DISPLACEMENT
         STC   R5,TBLDISP+TBLENTLN   INTO B5 OF NEXT TABLE ENTRY
INSTL    DS    0H                                             CFK*AUG01
         ICM   R5,B'0111',TBLADR  get current address         CFK*AUG01
         AH    R5,TBLOPLEN        add entry length            CFK*AUG01
         C     R5,EOC             TXT CARD BOUNDARY CROSSED?  CFK*AUG01
         BH    BDSK               yes, call 'DS' check routine
         BL    NODSB              no, continue
         CLC   NTCF(4),TNT1       all cards fetched ?
         BL    NODSB              br. if more cards to fetch
         OI    TFL,X'01'          set end of last card flag   CFK*SEP01
         B     NODSB
BDSK     BAL   R14,DSCK           CALL 'DS' CHECK ROUTINE
         B     INSTL              and repeat check for end of card
NODSB    TM    TBLFLG,X'0F'       IS THIS A TERMINAL INSTRUCTION
         BC    12,GOAGN           BRANCH IF NO
         LR    R5,TBL             IS THE PRECEEDING
         CLI   AOP1,X'45'           BAL instruction ?
         BNE   TS5                    Br if not
         CLI   CC,X'E0'             BAL 14, ?
         BE    TERM                   if so br
TS5      CLI   AOP1,X'05'           BALR instruction ?
         BNE   SGE                    Br if not
         S     R5,EIGHT           get @ prev table entry
         TM    0(R5),X'70'        prev entry an instruction ?
         BM    SGD                branch if yes
         MVI   TBLFLG,X'10'       else flag non-term instruction
         B     GOAGN
SGE      S     R5,EIGHT           CLASSIFICATION A
SGD      CLI   0(R5),X'00'        NON-TERM CONSTANT
         BE    CREDO              BRANCH IF YES
         CLI   0(R5),X'0E'        WAS PRECEEDING A TERMINAL CONSTANT?
         BNE   TERMT              branch if not
CREDO    MVI   TBLFLG,X'00'       CLASSIFY AS CONSTANT
         B     REDO               GO TO 'REDO'
TERMT    TM    AOP1,X'B0'         b'10110000'
         BNZ   TERM               br. if not x'0*' or x'4*'
         MVC   TAOP(1),AOP1       copy instruction
         NI    TAOP,X'0F'         clear high 4 bits
         CLI   TAOP,X'06'
         BNE   BC
         TM    AOP1,X'40'
         BO    TERM
         NI    TBLFLG,X'F0'
         B     GOAGN
BC       CLI   TAOP,X'07'
         BNE   TERM
         TM    CC,X'F0'
         BNZ   TERM
         NI    TBLFLG,X'F0'
         B     GOAGN
         TITLE '** I N S T R     F O L L O W E D   B Y    C O N S T **'
IFBC     CLI   TBLID,X'01'        *************************************
         BE    LAE
         S     TBL,EIGHT          get @ prev entry
AGNB     CLI   TBLID,X'01'        first entry ?
         BE    LAE                br. if yes
         S     TBL,EIGHT          get @ prev entry
         TM    TBLFLG,X'70'       * GO BACK IN TABLE UNTIL A CONSTANT *
         BNZ   AGNB               * CLASSIFICATION IS FOUND. CLASSIFY *
         LA    TBL,TBLENTLN(TBL)  * ENTRY AFTER IT AS A CONSTANT TOO. *
LAE      MVI   TBLFLG,X'00'       *                                   *
         B     REDO               *************************************
         TITLE '*** R L D    F O U N D *** '
FRLD     CLI   TBLID,X'01'        first entry ?
         BE    BADR               branch if yes
         S     TBL,EIGHT          get @ prev table entry
         TM    TBLFLG,X'70'       constant ?                  CFK*SEP01
         BNZ   AGNB               branch if not               CFK*SEP01
         LA    TBL,TBLENTLN(TBL)  back to this entry
BADR     L     R5,ARLD            ADJUST LENGTH OF CURRENT
         SLL   R5,8               clear top
         SRL   R5,8                byte
         MVC   CC(1),TBLFLG       save entry format
         MVI   TBLFLG,X'00'       make this a constant
         S     R5,TBLADR-1        ENTRY TO MAKE NEXT ENTRY
         ST    R5,FRA             save offset to RLD entry
         SR    R5,R5
         IC    R5,TBLDISP         get displacement into card
         LA    R14,BRF            set return address for 'DS' check
         A     R5,FRA             add offset to RLD entry
         C     R5,EOC             compare with @ end of card  CFK*AUG01
         BNL   DSCK               go to 'DS' check routine if so
BRF      L     R5,FRA             get offset to RLD entry
         LTR   R5,R5              is it zero ?
         BZ    EOA                 BRANCH IF ADCON
         STH   R5,TBLOPLEN        START AT RLD ADR
         AH    R5,TBLDISP-1       UPDATE TEXT ADR
         STC   R5,TBLDISP+TBLENTLN   DISPLACEMENT
         CLI   CC,X'8E'           was it zeroes or blanks ?
         BNE   NZR                branch if not
         MVI   TBLFLG,X'8E'       indicate zeroes or blanks
NZR      CLI   TBLID,X'0F'        last entry ?
         BE    TERM               br if yes
         LA    TBL,TBLENTLN(TBL)  TABLE POINTER TO NEXT ENTRY
EOA      MVI   TBLFLG,X'6E'        CLASSIFY AS ADCON
         MVC   TARLD(8),CRLDPRM   copy CRLD output
         MVC   TBLADR,ARLD+1      ADCON LOGICAL ADR TO B13
         MVC   TBLOPLEN,LRLD      ADCON LENGTH TO B67
         SR    R5,R5
         IC    R5,TBLDISP         get TXT card displacement
         AH    R5,TBLOPLEN        add entry length
         STC   R5,TBLDISP+TBLENTLN   save next entries displacement
         BAL   R14,ADCON          GET NEXT ADCON LOGICAL ADR
         ICM   R5,B'0111',TBLADR  get current address         CFK*AUG01
         AH    R5,TBLOPLEN        add entry length            CFK*AUG01
         C     R5,EOC             TXT CARD BOUNDARY CROSSED?  CFK*AUG01
         BL    TERM               br if card not finished
         BH    ADDS               go to call DS check
         CLC   NTCF(4),TNT1       all cards fetched ?
         BL    ADDS               br. if more cards to fetch
         OI    TFL,X'FF'          set end of last card flag   CFK*SEP01
         B     TERM               go to constant termination
ADDS     BAL   R14,DSCK           call 'DS' check routine
         B     TERM               GO TO CONSTANT TERMINATION
         TITLE '*** ''D S''    C H E C K ***  '
DSCK     L     R5,NTCF            INCREMENT
         LA    R5,1(R5)           FETCHED CARDS
         ST    R5,NTCF            COUNT BY ONE
         C     R5,TNTC            IS THIS THE LAST CARD?
         BNL   EFT                 BRANCH IF LAST CARD
         L     R3,CATXB           get @ current TXTB entry
         MVC   GPDW+1(3),TXTHADR  ************************************
         L     R5,GPDW            *                                  *
         SR    R6,R6              * COMPARE CURRENT TXTB ADR ENTRY + *
         IC    R6,TXTHLEN         * BYTE COUNT WITH NEXT TXTB ENTRY  *
         AR    R5,R6              *                                  *
         ST    R5,GPDW            ************************************
         CLC   GPDW+1(3),TXTHADR+TXTHDRLN   IS THERE A 'DS'?  CFK*MAY01
         BL    DSFND              BRANCH IF YES
         BE    NODSF              branch if no 'DS'
         ABEND 30,DUMP            DUMP (ILLEGAL TXT OVERLAY)
NODSF    LA    R3,TXTHDRLN(R3)    UPDATE TXTB POINTER         CFK*MAY01
         ST    R3,CATXB           save TXTB pointer
         SR    R5,R5               ) calculate                CFK*AUG01
         ICM   R5,B'0111',TXTHADR  )  @ first                 CFK*AUG01
         SR    R6,R6               )   byte after             CFK*AUG01
         IC    R6,TXTHLEN          )    current               CFK*AUG01
         AR    R5,R6               )     card                 CFK*AUG01
         ST    R5,EOC              save it for reuse          CFK*AUG01
         SR    R6,R6
         IC    R6,TXTHLEN         UPDATE NO. OF BYTES LEFT
         A     R6,NBLC            ON CARD BY AMOUNT OF NEW
         ST    R6,NBLC            TXTB BYTE COUNT ENTRY
         C     R6,HEXFF           more than 255 ?
         BHR   R14                return if higher
CLB      CLC   TBLADR+TBLENTLN,EOC+1     off end of card ?    CFK*AUG01
         BNL   DSCK               loop if not lower
         BR    R14                *** RETURN ***
EFT      MVI   TFL,X'FF'          SET end of LAST CARD FLAG
         B     DSFND
         TITLE '*** ''D S''    F O U N D ***  '
DSFND    LR    R5,TBL             WAS PRECEEDING
         S     R5,EIGHT           CLASSIFICATION
         TM    0(R5),X'70'        A CONSTANT or ZOBS?
         BZ    CSD                br. if yes
         MVI   TFL,X'00'          clear last card flag
         L     R6,NTCF            ) subtract 1
         BCTR  R6,0               ) from number
         ST    R6,NTCF            ) of TXT cards fetched
         B     AGNB
CSD      L     R5,EOC             get @ 1st byte of 'DS'      CFK*AUG01
         SR    R6,R6              * ADJUST LENGTH OF CURRENT CONSTANT *
         ICM   R6,B'0111',TBLADR  * SO THAT NEXT ENTRY I.C.   CFK*AUG01
         SR    R5,R6              * IS THE START OF THE 'DS' AREA.    *
         BZ    NZ                 skip code if zero length
         CLI   TBLFLG,X'00'       is current entry a const ?  CFK*SEP01
         BE    CSD2               if so carry on              CFK*SEP01
         CH    R5,TBLOPLEN        will it be lengthened ?     CFK*JUN01
         BNH   CSD2               if not carry on             CFK*JUN01
CSD1     DS    0H                 else need a constant entry  CFK*JUN01
         SH    R5,TBLOPLEN        sub prev len from this len  CFK*JUN01
         SR    R14,R14            clear work reg              CFK*JUN01
         IC    R14,TBLDISP        get displacement            CFK*JUN01
         AH    R14,TBLOPLEN       add prev entry length       CFK*JUN01
         STC   R14,TBLDISP+TBLENTLN   set displacement        CFK*JUN01
         ICM   R14,B'0111',TBLADR get TXT address             CFK*JUN01
         AH    R14,TBLOPLEN       add prev entry length       CFK*JUN01
         STCM  R14,B'0111',TBLADR+TBLENTLN  put into next     CFK*JUN01
         LA    TBL,TBLENTLN(TBL)  point @ next entry          CFK*JUN01
         MVI   TBLFLG,X'00'       flag constant               CFK*JUN01
         CH    R5,=H'4'           constant not too long       CFK*JUN01
         BNH   CSD2               br if OK                    CFK*JUN01
         MVC   TBLOPLEN,=H'4'     else gen 4 byte constant    CFK*JUN01
         B     CSD1               and back to get next        CFK*JUN01
CSD2     DS    0H                                             CFK*JUN01
         STH   R5,TBLOPLEN        *************************************
CSD3     DS    0H                                             CFK*JUN01
         MVI   CC,X'00'           assume next entry will be constant
         CLI   TBLFLG,X'6E'       adcon ?
         BE    NMZA               branch if yes
         CLI   TBLFLG,X'8E'       zeroes or blanks ?
         BNE   NMZ                branch if not
NMZA     MVC   CC(1),TBLFLG       save entry type
NMZ      MVI   TBLFLG,X'00'       CLASSIFY CURRENT ENTRY AS CONSTANT
         A     R5,TBLADR-1        FORM NEXT
         ST    R5,TBLADR-1+TBLENTLN    I.C. ENTRY
         MVC   TBLFLG,CC          set current entry type
         CLC   TBLOPLEN,ZEROS     zero ?
         BNE   IUD                br if not
         ABEND 555,DUMP           else error
IUD      LA    TBL,TBLENTLN(TBL)  get @ next entry
NZ       MVI   TBLFLG,X'7E'       CLASSIFY AS 'DS'
         CLI   TFL,X'00'          last card ?                 CFK*AUG01
         BE    NZE                br. if not                  CFK*AUG01
         S     TBL,EIGHT          get @ previous table entry
         CLI   TBLID,X'00'        start of table ?
         BE    LASTC              branch if yes
         B     TERMS              else pass back DS
NZE      L     R3,CATXB           get TXTB table pointer
         LA    R3,TXTHDRLN(R3)    UPDATE TXTB TABLE POINTER   CFK*MAY01
         ST    R3,CATXB           set TXTB table pointer
         SR    R14,R14             ) calculate                CFK*AUG01
         ICM   R14,B'0111',TXTHADR )  @ first                 CFK*AUG01
         SR    R5,R5               )   byte after             CFK*AUG01
         IC    R5,TXTHLEN          )    current               CFK*AUG01
         AR    R14,R5              )     card                 CFK*AUG01
         ST    R14,EOC             save it for reuse          CFK*AUG01
         L     R5,GPDW            *****************************
         MVC   GPDW+1(3),TXTHADR  * GET 'DS' LENGTH AND PLACE *
         S     R5,GPDW            * IN B67 OF CURRENT ENTRY   *
         LPR   R5,R5
         STH   R5,TBLOPLEN        *****************************
         MVC   NBLC+3(1),TXTHLEN  NEW BYTES LEFT COUNT
CADC     CLC   GPDW+1(3),ARLD+1   is next ADCON after DS ?
         BNH   TERMS              br. if yes
         BAL   R14,ADCON          get next ADCON logical address
         B     CADC               and try again
         TITLE '*** Z E R O E S    O R    B L A N K S ***  '
***********************************************************************
*                                                                     *
*        AT ENTRY 'R5' CONTAINS CURRENT TXTB POINTER & 'R6' HAS       *
*        ADR OF 'ZEROS' OR 'BLANK' (WHICH EVER OP CODE CONTAINED)     *
*                                                                     *
***********************************************************************
ZOBS     LR    R7,TBL             WAS PRECEEDING
         S     R7,EIGHT           CLASSIFICATION
         CLI   TBLID,X'01'        1st entry ?
         BE    ZADE               br if so
         TM    0(R7),X'70'         A CONSTANT ?
         BNZ   IFBC               BRANCH IF NO
ZADE     MVC   ZAD+1(3),TBLADR    copy TXT address
         MVI   TBLFLG,X'00'       flag constant
         L     R7,ZAD             ) calc
         LA    R7,8(R7)           ) current loc
         ST    R7,ZAD             ) + 8
         CLC   ZAD+1(3),ARLD+1    RLD entry in next 8 bytes ?
         BH    NZOB               branch if yes               CFK*SEP01
         MVI   TBLFLG,X'8E'       CLASSIFY CURRENT ENTRY AS 'ZOB'
         SR    R7,R7              UPDATE
         IC    R7,TBLDISP         BYTE COUNT
         A     R7,EIGHT           BY EIGHT
         ST    R5,TR5             STORE r5 (uselessly)
         ST    R6,TR6             store r6
* loop to find the end of the zeroes or blanks.
AGNC     ST    R5,TR5             STORE r5 TEMPORARILY
         LR    R6,R7              ) calc
         A     R6,EIGHT           ) current loc
         STC   R6,TBLDISP+TBLENTLN  ) + 8
         CLC   ZAD+1(3),ARLD+1    RLD entry in next 8 bytes ?
         BH    FRLD               branch if yes
         XR    R5,R5              clear work register         CFK*JUN01
         ICM   R5,B'0111',TBLADR  get current TXT disp        CFK*JUN01
         L     R14,ZAD            get latest ZOBS length      CFK*JUN01
         SR    R14,R5             calc latest ZOBS length     CFK*JUN01
         STH   R14,TBLOPLEN       save it for DSFND           CFK*JUN01
         L     R5,ZAD             )
         LA    R5,8(R5)           ) Increment @ ZOBS by 8
         ST    R5,ZAD             )
         ST    R7,TR7             save r7
         LA    R14,BR              LOAD RETURN ADDRESS FROM DSCK
         C     R5,EOC             HAS CARD BOUNDARY BEEN CROSSED? SEP01
         BH    DSCK               BRANCH IF YES
BR       L     R5,TR5             RESTORE REGISTER 5
         LA    R5,8(R5)           UPDATE TXTS POINTER
         L     R7,TR7             reload r7
         LA    R7,8(R7)           UPDATE BYTE COUNTER
         C     R7,HEXFF           HAS TXTS DISPLACEMENT EXCEEDED F'255'
         BH    ZBOUT              BRANCH IF YES
         L     R6,TR6             reload @ 'zeroes' or 'blank'
         CLC   0(8,R5),0(R6)      IS NEXT EIGHT BYTES OF TEXT THE SAME?
         BE    AGNC               BRANCH BACK IF YES
ZBOUT    S     R7,EIGHT           subtract 8
         S     R5,EIGHT           subtract 8
         SR    R6,R6              CALC
         IC    R6,TBLDISP         ZOB
         SR    R7,R6              LENGTH
         STH   R7,TBLOPLEN        PLACE LENGTH INTO B67
         B     TERM
         TITLE '*** T E R M I N A T I O N ***  '
TERME    TM    TBLFLG,X'70'       GO BACK IN TABLE UNTIL A
         B     TERM                CONSTANT CLASSIFICATION IS
         S     TBL,EIGHT          FOUND OR WHOLE TABLE HAS
         CLI   TBLID,X'01'        BEEN SEARCHED.  ACCEPT UP
         BH    TERME              TO RESULTANT TABLE ENTRY.
         ABEND 70,DUMP            DUMP IF NO CONSTANT FOUND
TERM     SR    R5,R5
         ICM   R5,B'0111',TBLADR  get current address         CFK*AUG01
         AH    R5,TBLOPLEN        add entry length            CFK*AUG01
         C     R5,EOC             compare with end of card    CFK*AUG01
         BL    TERMS              BR. IF END OF CARD NOT FOUNDCFK*AUG01
*        BZ    TT                  end of card
*        ABEND 11,DUMP             error - we overran the card
TT       L     R5,NTCF             LOAD NO OF CARDS FOUND
         LA    R5,1(R5)            INCREMENT CARD COUNT
         S     R5,TNTC             SUBTR TOTAL NUMBER OF CARDS
         BL    TERMS               HAS LAST CARD BEEN FOUND ?
         OI    TFL,X'01'           SET last card FLAG IF YES  CFK*AUG01
TERMS    L     R5,TBLADR-1        PLACE
         AH    R5,TBLOPLEN        NEXT I.C.
         ST    R5,FTBL            INTO B13 OF ENTRY ZERO
         MVI   FTBL,X'0F'         RETAIN END
         NC    FTBL(1),TBLFLG     CLASSIFICATION INFO.
         CLI   TBLFLG,X'00'       constant ?
         BE    ISE                branch if yes
         CLI   TBLFLG,X'5F'       instruction ?
         BH    ISE                branch if not
         OI    FTBL,X'01'
ISE      MVC   TBLTE+3(1),TBLID
         ST    R3,CATXB           SAVE CURRENT TXTB POINTER
         LA    TBL,FTBL+8         SET TABLE POINTER TO ENTRY
         ST    TBL,CATBL          ONE FOR PROCESS ROUTINE
         BAL   R14,PROCS          go to process routine
         TITLE '*** P R O C E S S ***  '
PROCS    L     TXS,SATXS          LOAD STARTING TEXT POINTER
*        S     TXS,SAVSDADR       - section start address     CFK*JAN04
         L     TBL,CATBL          LOAD CURRENT TABLE ENTRY POINTER
         L     PAA,PRM@PA         LOAD PRINT AREA POINTER
         USING OUTLINE,PAA        tell assembler              CFK*MAR00
         SR    R5,R5              ***********
         IC    R5,TBLFLG          * BRANCH  *
         SRL   R5,4               * TO SOME *
         SLL   R5,2               * PROCESS *
         L     R5,ALIST(R5)       * ROUTINE *
         BR    R5                 ***********
* Process routine to handle an ADCON
PRLD     MVC   PRMROUT4,AARL      EXTERNAL DECODE, @ ARL csect
         MVC   PRMINST4,0(TXS)    pass back TEXT of ADCON
         MVC   PRMINST4+4(8),TARLD  pass back RLD definition  CFK*APR00
         MVC   PRMLEN,TBLOPLEN    copy ADCON length to parms
         PUSH  USING                                          CFK*JUN03
         USING RLDITEM,TARLD                                  CFK*JUN03
         MVC   PRMOPER,RLDIFLAG   copy ADCON flags to parms   CFK*JUN03
         POP   USING                                          CFK*JUN03
         MVC   OUTINSTR(2),DCDS   copy c'DC' to print area
         B     PASSA
* Process routine to handle a constant
PCON     MVC   PRMROUT4,ACON      pass @ CONST TO PASS 4
MVDC     DS    0H                 'DC' TO PRINT               CFK*SEP01
         MVC   OUTINSTR(2),DCDS   AREA POS 65-66
         B     PASS               go to termination
         TITLE '*** P R O C E S S    I N S T R U C T I O N S *** '
PCRR     MVC   PRMROUT4,AXFRS     ************
         B     PINST              *          *
PCRX     MVC   PRMROUT4,AXFRS+4   * EXTERNAL *
         B     PINST              * DECODE   *
PCRS     MVC   PRMROUT4,AXFRS+8   * ROUTINE  *
         B     PINST              * ADR TO   *
PCSI     MVC   PRMROUT4,AXFRS+12  * PASS 4   *
         B     PINST              *          *
PCSS     MVC   PRMROUT4,AXFRS+16  ************
PINST    DS    0H                                             CFK*SEP01
* call to TIME deleted from here                              CFK*APR00
         MVC   AOP1(6),0(TXS)     OP CODE TO AXN DATA SECTION
         BAL   R14,CLAXN          GET BCD MNEMONIC FOR OP CODE
         MVC   AOPT,0(TXS)        copy opcode to INFO parms   CFK*APR00
         MVC   AFMT,AOP7          pass instr. flags to INFO   CFK*APR00
         LA    R14,RETT           get return address          CFK*APR00
         L     R15,AINFO          get @ INFO csect            CFK*APR00
         CNOP  2,4                                            CFK*APR00
         BASR  R1,R15             call INFO                   CFK*APR00
PAT      DC    A(PA)              @ print area in PASS1 csect CFK*APR00
AOPT     DS    XL6                instruction text            CFK*APR00
AFMT     DS    X                  instruction format flags    CFK*APR00
RETT     DS    0H                                             CFK*APR00
         L     R5,AXNOPC          ************************
         L     R6,0(R5)           * INCREMENT CURRENT OP *
         LA    R6,1(R6)           * CODE COUNTER BY ONE  *
         ST    R6,0(R5)           ************************
         MVC   OUTINSTR,AOP2      BCD MNEM. TO PRINT AREA
         ST    PAA,PRPAA          PRINT AREA ADR FOR PR ROUTINE
         MVC   PRTXT(8),0(TXS)    TEXT FOR PR
         MVC   PRLEN+2(2),TBLOPLEN  LENGTH OF TEXT FOR PR
*                                 call PR to format text for print
         LA    R1,PRPAA           get @ parms                 CFK*AUG01
         L     R15,ADRPR          get @ PR csect              CFK*AUG01
         BASR  R14,R15            call PR                     CFK*AUG01
         TITLE '*** P R O C E S S    T E R M I N A T I O N ***  '
PASS     MVC   PRMLEN,TBLOPLEN     TEXT LENGTH TO PASS 4
         MVC   PRMFMT(2),AOP5     Instr. and operand formats to PASS4
         MVC   PRMINST4,0(TXS)    8 BYTES OF TEXT TO PASS 4
PASSA    AH    TXS,TBLOPLEN       get @ next instruction
         L     R5,NBLC            get no. bytes left on card  CFK*AUG01
         SH    R5,TBLOPLEN        subtract length used        CFK*AUG01
         ST    R5,NBLC            and save it                 CFK*AUG01
PTRM     DS    0H                 called by PCDS only !       CFK*JLY01
         MVC   PRMFLG1(4),TBLFLG  I.C. & AXN CODE TO PASS 4
         UNPK  OUTLOC(7),TBLADR(4)  put address on listing    CFK*JLY01
         TR    OUTLOC,=C'0123456789ABCDEF'-240 make printable CFK*JLY01
         MVI   OUTLOC+6,C' '      clear gash byte             CFK*JLY01
*        A     TXS,SAVSDADR       add back section offset     CFK*JAN04
         ST    TXS,SATXS          SAVE TEXT POINTER
         SR    R5,R5              ZERO R5
         IC    R5,TBLID     INSERT TABLE ENTRY NUMBER
         C     R5,TBLTE           ENTRY BEEN REACHED?
         BL    RTN                BRANCH IF NO
         MVI   PCFLG,X'00'        RE-SET FLAG FOR LOOKAHEAD
         CLI   TFL,X'FF'          end of last card ?          CFK*AUG01
         BE    LASTC              br. if so                   CFK*AUG01
RTN      LA    TBL,TBLENTLN(TBL)  TABLE POINTER TO
         ST    TBL,CATBL          THE NEXT ENTRY
RET      L     R13,SAVE+4         ********************
         LM    R14,R12,12(R13)    * RETURN TO PASS 4 *
         BR    R14                ********************
         TITLE '*** I N S U B ***  (FORMAT BCD LENGTH FOR DS OR DC) '
INSUB    STM   R1,R2,24(R13)      SAVE R1 & R2 (USED IN TRANSLATE)
         LH    R5,TBLOPLEN        GET LENGTH
         TM    3(TBL),X'03'       on a fullword boundary ?
         BNZ   NFWD               branch if not
         TM    7(TBL),X'03'       IS LENGTH A MULTIPLE OF FOUR?
         BNZ   NFWD               BRANCH IF NOt
         SRL   R5,2               DIVIDE LENGTH BY FOUR
NFWD     CVD   R5,GPDW            GET DECIMAL
         UNPK  GPDW(5),GPDW+5(3)  LENGTH READY
         OI    GPDW+4,C'0'        FOR PRINT
         TRT   GPDW(5),TRTBL-240  FIND ADR OF FIRST NON-ZERO DIGIT
         BNO   CONTC              IN DECIMAL DS OR DC LENGTH
         ABEND 40,DUMP            DUMP IF LENGTH IS ALL ZEROES
CONTC    LA    R5,GPDW+4          FIND NO. OF BYTES
         SR    R5,1               TAKEN BY BCD LENGTH
         EX    R5,MOVE            MOVE BCD LENGTH TO PRINT AREA
         LA    R5,OUTOPER(R5)     FIND ADR OF BYTE RIGHT AFTER LENGTH
         LM    R1,R2,24(R13)      RESTORE R1 & R2
*
* AT EXIT 'R5' CONTAINS POINTER TO BYTE RIGHT AFTER BCD DS/DC LENGTH
*
         BR    R14                *** RETURN ***
MOVE     MVC   OUTOPER(1),0(R1)   EXecuted instruction        CFK*APR00
TRTBL    DC    X'00'
         DC    9X'FF'
         TITLE '*** P C D S ***  (PROCESS DS) '
PCDS     DS    0H                                             CFK*SEP01
         L     R3,CATXB           get @ current TXTB entry    CFK*JUN01
         XR    TXS,TXS            clear TXT pointer           CFK*JUN01
         ICM   TXS,B'0111',TXTHADR get new TXT offset         CFK*JUN01
         A     TXS,SAVTXPTR       add @ start of TXT          CFK*JUN01
         S     TXS,SAVSDADR       calc offset into section    CFK*MAR04
         ST    TXS,SATXS          save new TXT pointer        CFK*JUN01
         MVI   PCFLG,X'00'        ind. lookahead next call    CFK*DEC02
         MVC   OUTINSTR(2),DCDS+2 'DS' TO PRINT POS 65-66
         MVC   PRMROUT4,ADS       copy @ DS csect to decoding rtn adr
         BAL   R14,INSUB       call format BCD length for DS or DC rtn
*
*AFTER INSUB 'R5' CONTAINS ADR OF PRINT POSITION FOLLOWING BCD LENGTH
*
         MVI   1(R5),C'F'         assume fullword
         TM    TBLADRLB,X'03'     are we on a fullword boundary ?
         BNZ   GMC                if not length is in bytes
         TM    7(TBL),X'03'       * PLACE 'C' OR 'F' AFTER *
         BZ    PTRM               * BCD LENGTH AND GO TO   *
GMC      MVI   1(R5),C'C'         * TERMINATION OF PROCESS *
         B     PTRM               **************************
* AFTER INSUB 'R5' CONTAINS ADR OF PRINT POSITION FOLLOWING BCD LENGTH
         TITLE '*** P C Z B ***  (PROCESS ZEROES OR BLANKS)  '
PCZB     BAL   R14,INSUB       call format BCD length for DS or DC rtn
*
*
         MVC   PRMROUT4,ADS        copy @ DS csect to decoding rtn adr
         TM    TBLADRLB,X'03'      ON FULL WORD BOUNDARY
         BNZ   BZ4                 BRANCH IF NO
         TM    7(TBL),X'03'
         BNZ   BZ4
         CLI   0(TXS),X'00'       IS TEXT A GROUP OF ZEROES?
         BNE   BLNK               BRANCH IF NO
         MVC   1(4,R5),FBCD       INSERT F'0' AFTER BCD LENGTH
         B     MVDC
BLNK     MVC   1(7,R5),CBCD       INSERT C'    ' AFTER BSD LENGTH
         B     MVDC
FBCD     DC    X'C67DF07D'        F'0' IN BCD
CBCD     DC    X'C37D404040407D'  C'    ' IN BCD
FBCD3    DC    X'E77DF0F07D'      X'00' in bcd
CBCD3    DC    X'C37D407D'         C' ' in bcd
FBCD0    DC    X'C37DF0F0F0F07D'  C'0000' in bcd
BZ4      CLI   0(TXS),X'00'        IS TEXT A GROUB OF ZEROES
         BNE   BLN3                BRANCH IF BLANKS
         MVC   1(5,R5),FBCD3      copy X'00'
         B     MVDC
BLN3     MVC   1(4,R5),CBCD3      copy C' '
         B     MVDC
* end of last card reached
LASTC    L     R2,SAVE+4          get @ our reg's in save area
         L     R1,24(R2)          get @ parms
         MVC   PRMKEY4,ONE1       copy f'1' into KEY4
         MVI   TFL,X'00'          clear last card flag
         MVI   PCFLG,X'00'        re-set flag for lookahead
         SR    R5,R5              ZERO REGISTER
         STH   R5,LRLD            ZERO RLD LENGTH
         ST    R5,NTCF            ZERO TEXT CARD COUNT
         MVI   FPFLG,X'FF'        SET FIRST PASS FLAG
         L     R6,ARLF            get @ RLF in CRLD csect     CFK*APR03
         MVI   0(R6),X'00'        zero RLF in CRLD            CFK*APR03
         B     RET                and return to caller
         TITLE 'Common subroutines'                           CFK*AUG01
*               Call to AXN
* This subroutines return address is in R14, so just branch to AXN and
* it returns for us
CLAXN    DS    0H                                             CFK*APR00
         LA    R1,AXNPARMS        GET @ PARMS                 CFK*APR00
         L     R15,AAXN           get @ AXN csect             CFK*APR00
         BR    R15                CALL AXN                    CFK*APR00
         SPACE 3
*              Call to CRLD        (GET LOGICAL ADR OF NEXT ADCON)
* this subroutines return address is in R14, so just branch to CRLD and
* it returns for us
ADCON    DS    0H                                             CFK*DEC00
         LA    R1,CRLDPRM         get @ parms                 CFK*DEC00
         L     R15,ACRLD          get @ CRLD csect            CFK*DEC00
         BR    R15                CALL CRLD                   CFK*DEC00
         TITLE '*** F T X T A    C O N S T A N T    A R E A *** '
         LTORG                                                CFK*JLY01
AAXN     DC    A(AXN)             ADR OF AXN
ACRLD    DC    A(CRLD)            ADR OF CRLD
BLANK    DC    CL8' '             EIGHT BYTES OF BLANKS
EIGHT    DC    F'8'               constant
FOUR     DC    F'4'               constant
HEXFF    DC    F'255'             UPPER LIMIT OF ONE BYTE COUNTER
HITBL    DC    F'15'              HIGHEST TABLE ENTRY NO.
ONE1     DC    F'1'               constant
TWO2     DC    F'2'               constant
ZEROS    DC    D'0'               EIGHT BYTES OF ZEROES
ALIST    DC    A(PCON)            ************  0 - constant
         DC    A(PCRR)            * ADDRESS  *  1 - RR
         DC    A(PCRX)            * LIST     *  2 - RX
         DC    A(PCRS)            * USED     *  3 - RS
         DC    A(PCSI)            * TO GET   *  4 - SI
         DC    A(PCSS)            * SPECIFIC *  5 - SS
         DC    A(PRLD)            * PROCESS  *  6 - ADCON
         DC    A(PCDS)            * ROUTINE  *  7 - DS
         DC    A(PCZB)            ************  8 - Zeroes Or Blanks
DCDS     DC    C'DCDS'            'DC' & 'DS' MNEMONICS
ADRPR    DC    A(PR)              ADR OF TEXT FORMAT ROUTINE
APAB     DC    A(PAB)             SECOND PRINT AREA ADR (not used ?)
ACON     DC    A(CONST)           ************
AXFRS    DC    A(RR)              *          *
         DC    A(RX)              * EXTERNAL *
         DC    A(RS)              * FORMAT   *
         DC    A(SI)              * ROUTINES *
         DC    A(SS)              *          *
AARL     DC    A(ARL)             ************
ADS      DC    A(DS)              @ DS csect
ARLF     DC    A(RLF)             @ RLF in CRLD csect         CFK*APR03
AINFO    DC    A(INFO)            @ INFO csect                CFK*APR00
         TITLE '*** F T X T A    V A R I A B L E    A R E A *** '
* start of parameters for AXN, keep in order
AXNPARMS DC    0F'0'              AXN parameters              CFK*APR00
AOP1     DC    XL2'0'             Input opcode (6 bytes in, 2 out) UN99
AOP2     DC    CL5' '             Mnemonic returned by AXN    CFK*JUN99
AOP3     DC    XL2'0'             Output Opcode               CFK*JUN99
AOP4     DC    X'0'               Output old format code      CFK*JUN99
AOP5     DC    X'0'               O/P Opcode format (as AXNFMT) K*JUN99
AOP6     DC    X'0'               O/P operand format (as AXNOPER) JUN99
AOP7     DC    X'0'               O/P opcode flags (as AXNFLG2) K*APR00
         DC    XL3'0'             unused                      CFK*APR00
AXNOPC   DC    F'0'               OP CODE COUNTER ADR RETURNED HERE
* end of parameters for AXN
* start of parameters for PR, keep in order
PRPAA    DC    F'0'               PRINT AREA ADR
PRTXT    DC    2F'0'              TEXT TO BE FORMATTED
PRLEN    DC    F'0'               TEXT LENGTH
* end of parameters for PR
* start of parameters for CRLD, keep in order
CRLDPRM  DC    F'0'               ESD ID's of ADCON and it's target
ARLD     DC    F'0'               LOGICAL ADR OF NEXT ADCON (hb flags)
LRLD     DC    H'0'               LENGTH OF ADCON
CRLDID   DC    H'0'               current ESD ID              CFK*DEC01
* end of parameters for CRLD
ADRZB    DC    F'0'               ADR OF ZEROS OR BLANK ENTERING 'ZOBS'
AZBTS    DC    F'0'               TXTS POINTER AT ENTRY TO 'ZOBS'
CATXB    DC    F'0'               CURRENT TXTB TABLE POINTER
EOC      DC    F'0'               @ byte after end of cur. card K*AUG01
SAVSDADR DC    F'0'               saved section address       CFK*APR01
FPFLG    DC    X'FF'              FIRST PASS FLAG ('FF'=FIRST PASS)
PCFLG    DC    X'00'              PROCESS FLAG ('FF'=PROCESS)
TFL      DC    X'00'              LAST CARD FLAG
TFLNOT   EQU   X'00'                not last card             CFK*AUG01
TFLLAST  EQU   X'01'                last card being processed CFK*AUG01
TFLEND   EQU   X'FF'                end of last card reached  CFK*AUG01
CC       DC    X'00'              2nd byte of opcode
TAOP     DC    X'00'
FTBL     DS    16D                FETCHED TEXT TABLE
         DC    D'0'
GPDW     DC    D'0'               GENERAL PURPOSE DOUBLE WORD
TARLD    DC    2F'0'              copy of CRLD output
NBLC     DC    F'0'               NUMBER OF BYTES LEFT ON CARD
NTCF     DC    F'0'               NUMBER OF TXT CARDS FETCHED
ZAD      DC    F'0'               work area for ZOBS
TNTC     DC    F'0'               TOTAL NUMBER OF TXT CARDS
SATXS    DC    F'0'               TEXT POINTER (SATXS+B5=CURRENT TEXT)
SAVTXPTR DS    F                  @ first byte of TXT         CFK*MAY01
SAVE     DS    18F                SAVE AREA FOR FTXTA ROUTINE
FRA      DC    F'0'               work area for FRLD
TBLTE    DC    F'0'               TABLE TERMINATION ENTRY NUMBER
*
CATBL    DS    1F                 CURRENT TABLE ENTRY POINTER
TR5      DC    F'0'               temp store for R5
TR6      DC    F'0'               temp store for R6
TR7      DC    F'0'               temp store for R7
TM1      DC    F'0'               not used ?
TNT1     DC    F'0'               number of TXT cards (NTXT - 1)
*
* * * * * * * * * * * REGISTER ASSIGNMENT * * * * * * * * * * * * * * *
*
R0       EQU   0                                              CFK*APR00
R1       EQU   1                                              CFK*APR00
R2       EQU   2                                              CFK*APR00
R3       EQU   3                  CURRENT TXTB TABLE POINTER  CFK*DEC01
TBL      EQU   4                  CURRENT TABLE POINTER
R5       EQU   5                  GENERAL WORK REGISTER
R6       EQU   6                  GENERAL WORK REGISTER
R7       EQU   7                  GENERAL WORK REGISTER
PAA      EQU   8                  PRINT AREA POINTER
TXS      EQU   9                  CURRENT TEXT POINTER
R10      EQU   10                 @ FTXTA parms               CFK*APR00
R11      EQU   11                                             CFK*APR00
R12      EQU   12                 base register               CFK*APR00
R13      EQU   13                 @ SAVE (save area)          CFK*APR00
R14      EQU   14                                             CFK*APR00
R15      EQU   15                                             CFK*APR00
*
COFST    DC    F'0'               *****DUMMY*****, entry point
RFTXT    ABEND 60,DUMP            *****DUMMY*****, entry point
         END
